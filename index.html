<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>polys silly rngame</title>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Oswald:wght@400;700&family=Orbitron:wght@400;700&family=Shadows+Into+Light&family=Balthazar&family=Righteous&family=Amatic+SC:wght@400;700&family=Rubik+Mono+One&family=Gloria+Hallelujah&family=Kaushan+Script&family=Tangerine:wght@400;700&family=Bungee&display=swap" rel="stylesheet">
    
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: arial, sans-serif;
            background: linear-gradient(135deg, #ffc0cb 0%, #ffffff 100%);
            min-height: 100vh;
            transition: background 0.5s, color 0.5s;
        }
        
        body.dark-mode {
            background: linear-gradient(135deg, #2d2d2d 0%, #000000 100%);
            color: #fff;
        }
        
        body.dark-mode .container {
            background: rgba(30, 30, 30, 0.9);
            color: #fff;
        }
        
        body.dark-mode .stat-box {
            background: #333;
        }
        
        body.dark-mode .stat-label {
            color: #ccc;
        }
        
        body.dark-mode .cooldown-settings {
            background: #333;
            color: #fff;
        }
        
        body.dark-mode .cooldown-settings label {
            color: #ccc;
        }
        
        body.dark-mode .roll-display {
            background: #222;
            border-color: #ff69b4;
        }
        
        body.dark-mode .rng-box {
            background: transparent;
        }
        
        body.dark-mode .upgrade-box,
        body.dark-mode .inventory,
        body.dark-mode .enchant-inventory,
        body.dark-mode .index-category {
            background: #333;
            color: #fff;
        }
        
        body.dark-mode .inventory-item,
        body.dark-mode .enchant-item {
            background: #444;
        }
        
        body.dark-mode .upgrade-title {
            color: #ff69b4;
        }
        
        body.dark-mode .upgrade-info {
            color: #ccc;
        }
        
        body.dark-mode button {
            background: #555;
        }
        
        body.dark-mode button:hover {
            background: #777;
        }
        
        body.dark-mode input {
            background: #444;
            color: #fff;
            border-color: #666;
        }
        
        /* Toast notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            pointer-events: none;
        }
        
        .toast {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: toast-slide-in 0.3s ease-out;
            max-width: 400px;
            text-align: center;
            font-size: 14px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: auto;
        }
        
        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .toast.hide {
            opacity: 0;
            transform: translateY(-20px);
        }
        
        @keyframes toast-slide-in {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .toast-title {
            font-weight: bold;
            color: #ff69b4;
            margin-bottom: 5px;
            font-size: 16px;
        }
        
        .toast-message {
            font-size: 13px;
            opacity: 0.9;
        }
        
        .dark-mode-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #333;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            z-index: 1000;
            font-size: 14px;
        }
        
        .toast-toggle {
            position: fixed;
            top: 60px;
            right: 20px;
            background: #666;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            z-index: 1000;
            font-size: 12px;
        }
        
        body.dark-mode .dark-mode-toggle,
        body.dark-mode .toast-toggle {
            background: #666;
        }
        
        .toast-toggle.active {
            background: #4CAF50;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.9);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #ff69b4;
            margin-bottom: 30px;
            text-transform: lowercase;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .stat-box {
            background: #f0f0f0;
            padding: 15px 25px;
            border-radius: 10px;
            text-align: center;
        }
        .stat-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
            text-transform: lowercase;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #ff69b4;
        }
        
        /* NEW ROLLER CONTAINER */
        .roller-container {
            width: 100%;
            max-width: 750px;
            margin: 0 auto 30px;
            position: relative;
            background: rgba(240, 240, 240, 0.9);
            border-radius: 15px;
            padding: 20px;
            border: 3px solid #ff69b4;
            height: auto;
            min-height: 220px;
            max-height: 300px;
            overflow: hidden;
            transition: height 0.3s ease;
        }
        
        .roller-viewport {
            width: 100%;
            height: calc(100% - 60px);
            overflow-x: scroll;
            overflow-y: hidden;
            scrollbar-width: thin;
            scrollbar-color: #ff69b4 #f0f0f0;
            user-select: none;
            cursor: grab;
        }
        
        .roller-viewport:active {
            cursor: grabbing;
        }
        
        .roller-viewport::-webkit-scrollbar {
            height: 8px;
            display: block !important;
            visibility: visible !important;
        }
        
        .roller-viewport::-webkit-scrollbar-track {
            background: #f0f0f0;
            border-radius: 4px;
        }
        
        .roller-viewport::-webkit-scrollbar-thumb {
            background: #ff69b4;
            border-radius: 4px;
        }
        
        .slots-container {
            display: flex;
            gap: 10px;
            min-width: min-content;
            height: 100%;
            padding: 10px 0;
            align-items: center;
        }
        
        .slot-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        .slot {
            width: 70px;
            height: 90px;
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
            position: relative;
            overflow: hidden;
            font-family: Arial, sans-serif;
            padding: 3px;
            box-sizing: border-box;
        }
        
        /* Rank-specific fonts */
        .slot.font-fantasy { font-family: 'Roboto Mono', monospace; }
        .slot.font-giant { font-family: 'Oswald', sans-serif; }
        .slot.font-ultimate { font-family: 'Orbitron', sans-serif; }
        .slot.font-apex { font-family: 'Shadows Into Light', cursive; }
        .slot.font-omega { font-family: 'Balthazar', serif; }
        .slot.font-insane { font-family: monospace; }
        .slot.font-colossal { font-family: 'Righteous', cursive; }
        .slot.font-gargantuan { font-family: 'Amatic SC', cursive; }
        .slot.font-hyper { font-family: 'Rubik Mono One', monospace; }
        .slot.font-insurmountable { font-family: 'Gloria Hallelujah', cursive; }
        .slot.font-infinitude { font-family: 'Kaushan Script', cursive; }
        .slot.font-almighty { font-family: 'Bungee', cursive; }
        
        /* NULL secret special styling */
        .slot.null-secret {
            border: 2px solid;
            border-image: linear-gradient(90deg, white, black) 1;
        }
        
        .slot.null-secret .slot-value {
            color: gray !important;
            font-family: 'Tangerine', cursive !important;
            font-size: 28px !important; /* x2 bigger */
            font-weight: bold !important;
            background: linear-gradient(90deg, black, gray, white, gray, black) !important;
            -webkit-background-clip: text !important;
            -webkit-text-fill-color: transparent !important;
            background-clip: text !important;
            line-height: 1 !important;
            height: auto !important;
        }
        
        .slot.null-secret .slot-rank {
            font-size: 18px !important; /* x2 bigger */
            font-weight: bold !important;
            color: gray !important;
            background: linear-gradient(90deg, black, gray, white, gray, black) !important;
            -webkit-background-clip: text !important;
            -webkit-text-fill-color: transparent !important;
            background-clip: text !important;
        }
        
        /* Completionist animation */
        .slot.completionist-animating {
            animation: completionist-cycle 0.01s infinite;
        }
        
        @keyframes completionist-cycle {
            0% { font-family: Arial, sans-serif; }
            7.69% { font-family: 'Roboto Mono', monospace; }
            15.38% { font-family: 'Oswald', sans-serif; }
            23.07% { font-family: 'Orbitron', sans-serif; }
            30.76% { font-family: 'Shadows Into Light', cursive; }
            38.45% { font-family: 'Balthazar', serif; }
            46.14% { font-family: monospace; }
            53.83% { font-family: 'Righteous', cursive; }
            61.52% { font-family: 'Amatic SC', cursive; }
            69.21% { font-family: 'Rubik Mono One', monospace; }
            76.9% { font-family: 'Gloria Hallelujah', cursive; }
            84.59% { font-family: 'Kaushan Script', cursive; }
            92.28% { font-family: 'Bungee', cursive; }
            100% { font-family: Arial, sans-serif; }
        }
        
        .slot:hover {
            transform: translateY(-2px);
            border-color: #ff69b4;
            box-shadow: 0 4px 8px rgba(255, 105, 180, 0.2);
        }
        
        .slot.selected {
            border-color: #ff69b4;
            background: #fff5f9;
            box-shadow: 0 0 15px rgba(255, 105, 180, 0.4);
        }
        
        .slot.acceptable {
            border-color: #ff69b4;
            border-style: dashed;
            border-width: 3px;
            box-shadow: 0 0 0 2px rgba(255, 105, 180, 0.2);
        }
        
        .slot-value {
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            text-align: center;
            width: 100%;
            line-height: 1.2;
            word-break: break-word;
            overflow-wrap: break-word;
            max-height: 40px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
            padding: 2px 0;
            position: relative;
            z-index: 1;
        }
        
        .slot-value.multiline {
            font-size: 12px;
            line-height: 1.1;
        }
        
        .slot-variant {
            font-size: 10px;
            background: #ff69b4;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            margin-bottom: 4px;
            text-transform: lowercase;
            width: 90%;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            position: relative;
            z-index: 2;
        }
        
        .slot-rank {
            font-size: 9px;
            margin-top: 2px;
            text-transform: lowercase;
            width: 90%;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            position: relative;
            z-index: 3;
            padding: 1px 0;
            min-height: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .slot-rank.solar-rank { color: orange !important; }
        .slot-rank.completionist-rank { 
            color: #00ffff !important;
            animation: completionist-color-cycle 0.12s infinite;
        }
        .slot-rank.poly-squared-rank { 
            color: #FF00FF !important;
            animation: pulse 1s infinite;
        }
        .slot-rank.null-rank {
            font-size: 18px !important;
            font-weight: bold !important;
            background: linear-gradient(90deg, black, gray, white, gray, black) !important;
            -webkit-background-clip: text !important;
            -webkit-text-fill-color: transparent !important;
            background-clip: text !important;
        }
        
        @keyframes completionist-color-cycle {
            0% { color: #aad7e6; } /* common */
            7.69% { color: #ff69b4; } /* fantasy */
            15.38% { color: #ff69b4; } /* giant */
            23.07% { color: #ff69b4; } /* ultimate */
            30.76% { color: #ff69b4; } /* apex */
            38.45% { color: #ff69b4; } /* omega */
            46.14% { color: #ff69b4; } /* insane */
            53.83% { color: #ff69b4; } /* colossal */
            61.52% { color: #ff69b4; } /* gargantuan */
            69.21% { color: #ff69b4; } /* hyper */
            76.9% { color: #ff69b4; } /* insurmountable */
            84.59% { color: #ff69b4; } /* infinitude */
            92.28% { color: #ff69b4; } /* almighty */
            100% { color: #aad7e6; } /* common */
        }
        
        .slot-stars {
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 8px;
            color: gold;
            z-index: 4;
        }
        
        .slot-enchant {
            position: absolute;
            bottom: 2px;
            left: 2px;
            font-size: 7px;
            background: #9370db;
            color: white;
            padding: 1px 3px;
            border-radius: 3px;
            font-weight: bold;
            width: 64px;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            z-index: 2;
            max-height: 12px;
            line-height: 1;
        }
        
        .selected-slot-details {
            margin-top: 20px;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 10px;
            border: 2px solid #ff69b4;
            max-height: 150px;
            overflow-y: auto;
            word-wrap: break-word;
            font-size: 14px;
        }
        
        .selected-slot-title {
            font-size: 18px;
            font-weight: bold;
            color: #ff69b4;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .selected-slot-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .selected-slot-info div {
            padding: 5px;
            background: white;
            border-radius: 5px;
            text-align: center;
            word-break: break-all;
        }
        
        .selected-slot-actions {
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        
        .slot-buttons {
            display: flex;
            gap: 5px;
            opacity: 0.5;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        
        .slot-wrapper.acceptable .slot-buttons {
            opacity: 1;
            pointer-events: auto;
        }
        
        .slot-accept-btn, .slot-decline-btn {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s;
        }
        
        .slot-accept-btn {
            background: #90ee90;
            color: black;
        }
        
        .slot-decline-btn {
            background: #ff4444;
            color: white;
        }
        
        .slot-accept-btn:hover, .slot-decline-btn:hover {
            transform: scale(1.1);
        }
        
        .accept-btn {
            background: #90ee90;
            color: black;
            border: none;
            padding: 8px 20px;
            font-size: 14px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        .decline-btn {
            background: #ff4444;
            color: white;
            border: none;
            padding: 8px 20px;
            font-size: 14px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        .accept-btn:hover {
            background: #7cd87c;
        }
        .decline-btn:hover {
            background: #ff3333;
        }
        button {
            background: #666;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s;
            text-transform: lowercase;
        }
        button:hover {
            background: #888;
            transform: translateY(-2px);
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        .button-container {
            text-align: center;
            margin-bottom: 30px;
        }
        .sections-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 30px;
        }
        @media (max-width: 900px) {
            .sections-container {
                grid-template-columns: 1fr;
            }
        }
        .upgrades-section, .inventory-section {
            margin-top: 20px;
        }
        .upgrades-header, .inventory-header, .enchants-header, .index-header {
            background: #666;
            color: white;
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            user-select: none;
            margin-bottom: 10px;
            text-transform: lowercase;
        }
        .upgrades-header:hover, .inventory-header:hover, .enchants-header:hover, .index-header:hover {
            background: #888;
        }
        .upgrades-content, .inventory-content, .enchants-content, .index-content {
            display: none;
        }
        .upgrades-content.open, .inventory-content.open, .enchants-content.open, .index-content.open {
            display: block;
        }
        .upgrade-box {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ddd;
            margin-bottom: 10px;
        }
        .upgrade-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #ff69b4;
            text-transform: lowercase;
        }
        .upgrade-info {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
        }
        .inventory, .enchant-inventory {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 10px;
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        .inventory-title, .enchant-title {
            font-weight: bold;
            font-size: 18px;
            color: #ff69b4;
            margin-bottom: 15px;
            text-transform: lowercase;
        }
        .inventory-item, .enchant-item {
            background: white;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: border 0.3s;
            position: relative;
        }
        
        /* Inventory Outline Tiers */
        .inventory-item.tier-1 { 
            border: 3px solid white;
            border-top: 15px solid white;
        }
        .inventory-item.tier-2 { 
            border: 3px solid yellow;
            border-top: 15px solid yellow;
        }
        .inventory-item.tier-3 { 
            border: 3px solid blue;
            border-top: 15px solid blue;
        }
        .inventory-item.tier-4 { 
            border: 3px solid cyan;
            border-top: 15px solid cyan;
        }
        .inventory-item.tier-5 { 
            border: 3px solid orange;
            border-top: 15px solid orange;
        }
        .inventory-item.tier-6 { 
            border: 3px solid pink;
            border-top: 15px solid pink;
        }
        .inventory-item.tier-7 { 
            border: 3px solid lime;
            border-top: 15px solid lime;
        }
        .inventory-item.tier-8 { 
            border: 3px solid;
            border-top: 15px solid;
            border-image: linear-gradient(90deg, gray, white, gray) 1;
            animation: spin-gradient 2s linear infinite;
        }
        .inventory-item.tier-9 { 
            border: 3px solid;
            border-top: 15px solid;
            border-image: linear-gradient(90deg, #FFFF00, white, #FFFF00) 1;
            animation: spin-gradient 2s linear infinite;
        }
        .inventory-item.tier-10 { 
            border: 3px solid;
            border-top: 15px solid;
            border-image: linear-gradient(90deg, #FF00FF, #00FFFF, #FF00FF, #00FFFF) 1;
            animation: spin-gradient 1s linear infinite;
        }
        .inventory-item.tier-11 { 
            border: 3px solid;
            border-top: 15px solid;
            border-image: linear-gradient(90deg, red, black, red) 1;
        }
        .inventory-item.tier-12 { 
            border: 3px solid;
            border-top: 15px solid;
            border-image: linear-gradient(90deg, #FF69B4, #9370DB, #FF69B4) 1;
            animation: spin-gradient 0.5s linear infinite;
        }
        .inventory-item.tier-13 { 
            border: 3px solid;
            border-top: 15px solid;
            border-image: linear-gradient(90deg, cyan, #00008B, cyan) 1;
            animation: spin-gradient 0.5s linear infinite;
        }
        .inventory-item.tier-14 { 
            border: 3px solid;
            border-top: 15px solid;
            border-image: linear-gradient(90deg, white, black, white) 1;
            animation: spin-gradient 0.5s linear infinite;
        }
        
        .tier-name {
            position: absolute;
            top: -17px;
            left: 10px;
            font-size: 10px;
            font-weight: bold;
            background: inherit;
            padding: 0 5px;
            color: inherit;
            text-transform: uppercase;
        }
        
        .tier-stars {
            position: absolute;
            bottom: -10px;
            right: 10px;
            font-size: 9px;
            color: gold;
            background: rgba(0,0,0,0.7);
            padding: 1px 4px;
            border-radius: 3px;
        }
        
        @keyframes spin-gradient {
            0% { border-image-source: linear-gradient(0deg, gray, white, gray); }
            100% { border-image-source: linear-gradient(360deg, gray, white, gray); }
        }
        
        .inventory-rng {
            font-weight: bold;
            font-size: 16px;
        }
        .inventory-details {
            font-size: 14px;
            color: #666;
            text-transform: lowercase;
        }
        .index-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .index-category {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            margin-bottom: 10px;
        }
        .index-title {
            font-weight: bold;
            color: #ff69b4;
            margin-bottom: 10px;
            border-bottom: 2px solid #ff69b4;
            padding-bottom: 5px;
            text-transform: lowercase;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .index-title::after {
            content: '‚ñº';
            font-size: 12px;
            transition: transform 0.3s;
        }
        .index-title.collapsed::after {
            transform: rotate(-90deg);
        }
        .index-items {
            max-height: 200px;
            overflow-y: auto;
            transition: max-height 0.3s ease;
        }
        .index-items.collapsed {
            max-height: 0;
            overflow: hidden;
        }
        .index-item {
            margin-bottom: 5px;
            padding: 3px 0;
            border-bottom: 1px solid #eee;
            text-transform: lowercase;
            font-family: Arial, sans-serif;
        }
        
        /* Index rank fonts */
        .index-item.rank-fantasy { font-family: 'Roboto Mono', monospace; }
        .index-item.rank-giant { font-family: 'Oswald', sans-serif; }
        .index-item.rank-ultimate { font-family: 'Orbitron', sans-serif; }
        .index-item.rank-apex { font-family: 'Shadows Into Light', cursive; }
        .index-item.rank-omega { font-family: 'Balthazar', serif; }
        .index-item.rank-insane { font-family: monospace; }
        .index-item.rank-colossal { font-family: 'Righteous', cursive; }
        .index-item.rank-gargantuan { font-family: 'Amatic SC', cursive; }
        .index-item.rank-hyper { font-family: 'Rubik Mono One', monospace; }
        .index-item.rank-insurmountable { font-family: 'Gloria Hallelujah', cursive; }
        .index-item.rank-infinitude { font-family: 'Kaushan Script', cursive; }
        .index-item.rank-almighty { font-family: 'Bungee', cursive; }
        .index-item.null-rank {
            font-family: 'Tangerine', cursive !important;
            font-weight: bold;
            background: linear-gradient(90deg, black, gray, white, gray, black) !important;
            -webkit-background-clip: text !important;
            -webkit-text-fill-color: transparent !important;
            background-clip: text !important;
        }
        
        .equip-btn {
            background: #90ee90;
            color: black;
            border: none;
            padding: 3px 8px;
            font-size: 11px;
            border-radius: 3px;
            cursor: pointer;
            margin-left: 5px;
        }
        .unequip-btn {
            background: #ff4444;
            color: white;
            border: none;
            padding: 3px 8px;
            font-size: 11px;
            border-radius: 3px;
            cursor: pointer;
            margin-left: 5px;
        }
        .star-display {
            font-size: 16px;
            margin-bottom: 3px;
            color: gold;
        }
        .merge-section {
            margin-top: 20px;
            background: #f9f9f9;
            padding: 15px;
            border-radius: 10px;
            width: 200px;
        }
        .merge-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 10px;
        }
        .merge-select {
            padding: 5px;
            border-radius: 5px;
            border: 2px solid #ddd;
            font-size: 12px;
            width: 100%;
        }
        .merge-info {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }
        .locked-enchant {
            opacity: 0.7;
            position: relative;
        }
        .locked-enchant::after {
            content: 'üîí';
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 10px;
        }
        .autoroll-controls {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }
        .autorow-toggle {
            background: #4CAF50;
            color: white;
        }
        .autorow-toggle.paused {
            background: #ff9800;
        }
        .autorow-toggle.stopped {
            background: #f44336;
        }
        .solar-rank {
            color: orange !important;
        }
        .completionist-rank {
            color: #00ffff !important;
            animation: completionist-color-cycle 0.12s infinite;
        }
        .poly-squared-rank {
            color: #FF00FF !important;
            animation: pulse 1s infinite;
        }
        .ahur-yp-rank {
            color: #9b30ff !important;
            animation: ahur-yp-pulse 0.5s infinite alternate;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        @keyframes ahur-yp-pulse {
            0% { opacity: 1; text-shadow: 0 0 5px #9b30ff; }
            100% { opacity: 0.8; text-shadow: 0 0 15px #9b30ff; }
        }
        
        .tickets-upgrades {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            border: 2px solid #ffd700;
        }
        .tickets-title {
            color: #ffd700;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            font-size: 20px;
        }
        .spinner-section {
            background: #f0f8ff;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            border: 2px dashed #9370db;
            text-align: center;
        }
        .wheel {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            border: 5px solid #ff69b4;
            margin: 15px auto;
            position: relative;
            overflow: hidden;
            transition: transform 3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .wheel-segment {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-origin: 50% 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: black;
            text-align: center;
            font-weight: bold;
        }
        .wheel-pointer {
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 12px solid transparent;
            border-right: 12px solid transparent;
            border-top: 20px solid #ff4444;
            z-index: 10;
        }
        
        body.dark-mode .roller-container {
            background: rgba(60, 60, 60, 0.9);
            border-color: #ff69b4;
        }
        
        body.dark-mode .slot {
            background: #444;
            border-color: #666;
            color: white;
        }
        
        body.dark-mode .selected-slot-details {
            background: #333;
            border-color: #ff69b4;
        }
        
        body.dark-mode .selected-slot-info div {
            background: #444;
        }
        
        /* Secret rank display styles */
        .slot-value.secret-display {
            font-size: 14px;
            font-weight: bold;
        }
        
        .roll-indicator {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 9px;
            color: #ff69b4;
            font-weight: bold;
            z-index: 5;
        }
        
        /* Secret animation */
        .slot-value.secret-animating {
            animation: secret-reveal 0.75s ease-in-out;
        }
        
        .slot-rank.secret-animating {
            animation: secret-reveal 0.75s ease-in-out;
        }
        
        @keyframes secret-reveal {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.25); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        /* Slot states */
        .slot.unrolled {
            color: #999;
        }
        
        .slot.rolled {
            transition: all 0.3s ease;
        }
        
        /* Drag scroll for roller */
        .roller-viewport.dragging {
            cursor: grabbing;
            user-select: none;
        }
        
        /* Unmerge button */
        .unmerge-btn {
            background: #ff8800;
            color: white;
            border: none;
            padding: 3px 8px;
            font-size: 11px;
            border-radius: 3px;
            cursor: pointer;
            margin-left: 5px;
        }
        
        /* Almighty rank font */
        .font-almighty {
            font-family: 'Bungee', cursive !important;
        }
        
        /* Index completionist item */
        .index-item.completionist-index {
            color: #00ffff !important;
            animation: completionist-color-cycle 0.12s infinite;
        }
        
        /* Obfuscation animation */
        .slot-value.obfuscating {
            animation: obfuscate 0.5s infinite alternate;
        }
        
        .slot-rank.obfuscating {
            animation: obfuscate 0.5s infinite alternate;
        }
        
        @keyframes obfuscate {
            0% { opacity: 1; }
            100% { opacity: 0.3; }
        }
        
        /* Bottom stats */
        .bottom-stats {
            margin-top: 40px;
            background: #f9f9f9;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #ff69b4;
        }
        
        .bottom-stats-title {
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            color: #ff69b4;
            margin-bottom: 20px;
            text-transform: lowercase;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .stat-item {
            background: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #ddd;
        }
        
        .stat-item-title {
            font-size: 14px;
            color: #666;
            margin-bottom: 8px;
            text-transform: lowercase;
        }
        
        .stat-item-value {
            font-size: 24px;
            font-weight: bold;
            color: #ff69b4;
        }
        
        body.dark-mode .bottom-stats {
            background: #333;
            border-color: #ff69b4;
        }
        
        body.dark-mode .stat-item {
            background: #444;
            border-color: #666;
        }
    </style>
</head>
<body>
    <!-- Toast container -->
    <div class="toast-container" id="toastContainer"></div>
    
    <button class="dark-mode-toggle" onclick="toggleDarkMode()">üåô Dark Mode</button>
    <button class="toast-toggle active" id="toastToggleBtn" onclick="toggleToastNotifications()">üîî Toasts ON</button>
    
    <div class="container">
        <h1>polys silly rngame</h1>
        
        <div class="stats">
            <div class="stat-box">
                <div class="stat-label">polycoin</div>
                <div class="stat-value" id="polycoin">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">best roll</div>
                <div class="stat-value" id="best">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">total rolls</div>
                <div class="stat-value" id="rolls">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">enchants</div>
                <div class="stat-value" id="enchants">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">roll coins</div>
                <div class="stat-value" id="rollCoins">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">tickets</div>
                <div class="stat-value" id="tickets">0</div>
            </div>
        </div>

        <div class="autoroll-controls">
            <button class="autorow-toggle" id="autorollBtn" onclick="toggleAutoroll()">‚ñ∂Ô∏è Start Autoroll</button>
            <div style="margin-top: 10px;">
                <label style="font-size: 14px; color: #666;">Pause on RNG ‚â• </label>
                <input type="number" id="pauseRNG" value="0" min="0" style="width: 100px; padding: 5px; border-radius: 5px; border: 2px solid #ddd;">
            </div>
            <div style="margin-top: 10px;">
                <label style="font-size: 14px; color: #666;">Pause on Secret Rarity ‚â• </label>
                <input type="number" id="pauseSecretRarity" value="0" min="0" style="width: 100px; padding: 5px; border-radius: 5px; border: 2px solid #ddd;">
            </div>
            <div style="margin-top: 10px;">
                <label style="font-size: 14px; color: #666;">Pause on Enchant Rarity ‚â• </label>
                <input type="number" id="pauseEnchantRarity" value="0" min="0" style="width: 100px; padding: 5px; border-radius: 5px; border: 2px solid #ddd;">
            </div>
        </div>

        <div class="cooldown-settings" style="text-align: center; margin-bottom: 20px; background: #f0f0f0; padding: 15px; border-radius: 10px;">
            <div style="display: inline-block; margin: 0 15px;">
                <label style="font-size: 14px; color: #666;">cooldown if RNG ‚â• </label>
                <input type="number" id="cooldownThreshold" value="0" min="0" step="1000" 
                    onchange="updateCooldownSettings()" 
                    style="width: 100px; padding: 5px; border-radius: 5px; border: 2px solid #ddd;">
            </div>
            <div style="display: inline-block; margin: 0 15px;">
                <label style="font-size: 14px; color: #666;">cooldown time (s): </label>
                <input type="number" id="cooldownTime" value="3" min="0.5" max="60" step="0.5" 
                    onchange="updateCooldownSettings()" 
                    style="width: 80px; padding: 5px; border-radius: 5px; border: 2px solid #ddd;">
            </div>
        </div>

        <!-- NEW ROLLER CONTAINER -->
        <div class="roller-container">
            <div class="roller-viewport" id="rollerViewport">
                <div class="slots-container" id="slotsContainer">
                    <!-- Slots will be generated here -->
                </div>
            </div>
            <div class="selected-slot-details" id="selectedSlotDetails" style="display: none;">
                <!-- Selected slot details will appear here -->
            </div>
        </div>

        <div class="button-container">
            <button onclick="roll()" id="rollBtn">roll</button>
        </div>

        <div class="tickets-upgrades">
            <div class="tickets-title">üé´ Ticket Shop</div>
            <div class="upgrade-box">
                <div class="upgrade-title">min speed reduction</div>
                <div class="upgrade-info">level: <span id="minSpeedLevel">0</span>/4</div>
                <div class="upgrade-info">effect: -0.01s min roll speed</div>
                <button onclick="buyMinSpeedUpgrade()" id="minSpeedBtn">buy (cost: <span id="minSpeedCost">5</span> tickets)</button>
            </div>
            <div class="upgrade-box">
                <div class="upgrade-title">spinner unlock</div>
                <div class="upgrade-info">status: <span id="spinnerStatus">locked</span></div>
                <div class="upgrade-info">effect: unlock enchant spinner</div>
                <button onclick="buySpinner()" id="spinnerBtn" disabled>buy (cost: <span id="spinnerCost">10</span> tickets)</button>
            </div>
            <div class="upgrade-box">
                <div class="upgrade-title">ticket production</div>
                <div class="upgrade-info">level: <span id="ticketProdLevel">0</span>/2</div>
                <div class="upgrade-info">effect: +1 ticket per minute</div>
                <button onclick="buyTicketProduction()" id="ticketProdBtn">buy (cost: <span id="ticketProdCost">50</span> tickets)</button>
            </div>
            
            <div class="spinner-section" id="spinnerSection" style="display: none;">
                <div class="upgrade-title">üé° Enchant Spinner</div>
                <div class="wheel" id="spinnerWheel">
                    <div class="wheel-pointer"></div>
                </div>
                <button onclick="spinWheel()" id="spinBtn" disabled>Spin (5 tickets)</button>
                <div id="spinResult" style="margin-top: 10px; font-size: 14px; color: #666;"></div>
            </div>
        </div>

        <div class="sections-container">
            <div class="left-column">
                <div class="upgrades-section">
                    <div class="upgrades-header" onclick="toggleSection('upgradesContent')">
                        ‚öôÔ∏è upgrades (click to expand) ‚öôÔ∏è
                    </div>
                    <div class="upgrades-content" id="upgradesContent">
                        <div class="upgrade-box">
                            <div class="upgrade-title">add roller</div>
                            <div class="upgrade-info">rollers: <span id="bulkLevel">1</span>/100</div>
                            <div class="upgrade-info">effect: +1 roller on screen</div>
                            <button onclick="buyUpgrade('bulk')" id="bulkBtn">buy (cost: <span id="bulkCost">100</span>)</button>
                        </div>
                        <div class="upgrade-box">
                            <div class="upgrade-title">luck boost</div>
                            <div class="upgrade-info">level: <span id="luckLevel">0</span>/100</div>
                            <div class="upgrade-info">effect: +<span id="luckAmount">0</span> luck</div>
                            <button onclick="buyUpgrade('luck')" id="luckBtn">buy (cost: <span id="luckCost">10</span>)</button>
                        </div>
                        <div class="upgrade-box">
                            <div class="upgrade-title">secret luck</div>
                            <div class="upgrade-info">level: <span id="secretLevel">0</span>/25</div>
                            <div class="upgrade-info">effect: +<span id="secretAmount">0</span> secret luck</div>
                            <button onclick="buyUpgrade('secret')" id="secretBtn">buy (cost: <span id="secretCost">50</span>)</button>
                        </div>
                        <div class="upgrade-box">
                            <div class="upgrade-title">roll speed</div>
                            <div class="upgrade-info">level: <span id="speedLevel">0</span>/25</div>
                            <div class="upgrade-info">speed: <span id="speedAmount">3.0</span>s</div>
                            <button onclick="buyUpgrade('speed')" id="speedBtn">buy (cost: <span id="speedCost">50</span>)</button>
                        </div>
                        <div class="upgrade-box">
                            <div class="upgrade-title">inventory slots</div>
                            <div class="upgrade-info">slots: <span id="invLevel">10</span>/50</div>
                            <div class="upgrade-info">effect: +1 inventory slot</div>
                            <button onclick="buyUpgrade('inventory')" id="invBtn">buy (cost: <span id="invCost">0</span>)</button>
                        </div>
                        <div class="upgrade-box">
                            <div class="upgrade-title">enchant luck</div>
                            <div class="upgrade-info">level: <span id="enchantLuckLevel">0</span>/15</div>
                            <div class="upgrade-info">effect: +<span id="enchantLuckAmount">0</span> enchant luck</div>
                            <button onclick="buyUpgrade('enchantLuck')" id="enchantLuckBtn">buy (cost: <span id="enchantLuckCost">30</span>)</button>
                        </div>
                        <div class="upgrade-box">
                            <div class="upgrade-title">variant luck</div>
                            <div class="upgrade-info">level: <span id="variantLuckLevel">0</span>/30</div>
                            <div class="upgrade-info">effect: +<span id="variantLuckAmount">0</span> variant luck</div>
                            <button onclick="buyUpgrade('variantLuck')" id="variantLuckBtn">buy (cost: <span id="variantLuckCost">50</span>)</button>
                        </div>
                        <!-- NEW UPGRADES -->
                        <div class="upgrade-box">
                            <div class="upgrade-title">eternium</div>
                            <div class="upgrade-info">level: <span id="eterniumLevel">0</span>/4</div>
                            <div class="upgrade-info">effect: +<span id="eterniumAmount">0</span>% chance for double bulk</div>
                            <button onclick="buyUpgrade('eternium')" id="eterniumBtn">buy (cost: <span id="eterniumCost">1e12</span>)</button>
                        </div>
                        <div class="upgrade-box">
                            <div class="upgrade-title">ultimatiplier</div>
                            <div class="upgrade-info">level: <span id="ultimatiplierLevel">0</span>/100</div>
                            <div class="upgrade-info">effect: +<span id="ultimatiplierAmount">0</span>% chance for x5 RNG</div>
                            <button onclick="buyUpgrade('ultimatiplier')" id="ultimatiplierBtn">buy (cost: <span id="ultimatiplierCost">100</span>)</button>
                        </div>
                    </div>
                </div>

                <div class="inventory-section">
                    <div class="inventory-header" onclick="toggleSection('inventoryContent')">
                        üì¶ inventory (<span id="invCount">0</span>/<span id="invMax">10</span>)
                    </div>
                    <div class="inventory-content open" id="inventoryContent">
                        <div class="inventory" id="inventoryList"></div>
                    </div>
                </div>

                <div class="merge-section">
                    <div class="inventory-title">üîÑ Enchant Merging</div>
                    <div class="merge-controls">
                        <select id="mergeOrb1" class="merge-select" onchange="updateMergePreview()">
                            <option value="-1">Select first orb</option>
                        </select>
                        <select id="mergeOrb2" class="merge-select" onchange="updateMergePreview()">
                            <option value="-1">Select second orb</option>
                        </select>
                        <button onclick="mergeEnchants()" id="mergeBtn" disabled>Merge (500 roll coins)</button>
                        <button onclick="unmergeEnchantOrb()" id="unmergeBtn" disabled style="background: #ff8800;">Unmerge (100k roll coins)</button>
                    </div>
                    <div class="merge-info" id="mergePreview">
                        Select two orbs to merge. Original orbs will be deleted.
                    </div>
                </div>
            </div>

            <div class="right-column">
                <div class="enchants-section">
                    <div class="enchants-header" onclick="toggleSection('enchantsContent')">
                        üîÆ enchants (<span id="enchantCount">0</span>)
                    </div>
                    <div class="enchants-content open" id="enchantsContent">
                        <div class="inventory-title">equipped orb</div>
                        <div class="inventory" id="equippedEnchant"></div>
                        <div class="inventory-title" style="margin-top: 15px;">enchant orbs</div>
                        <div class="inventory" id="enchantInventoryList"></div>
                    </div>
                </div>

                <div class="index-section">
                    <div class="index-header" onclick="toggleSection('indexContent')">
                        üìö index (click to expand)
                    </div>
                    <div class="index-content" id="indexContent">
                        <div class="index-grid">
                            <div class="index-category" onclick="toggleIndexCategory('variantsIndex')">
                                <div class="index-title">variants</div>
                                <div class="index-items" id="variantsIndexItems"></div>
                            </div>
                            <div class="index-category" onclick="toggleIndexCategory('normalRanksIndex')">
                                <div class="index-title">normal ranks</div>
                                <div class="index-items" id="normalRanksIndexItems"></div>
                            </div>
                            <div class="index-category" onclick="toggleIndexCategory('secretRanksIndex')">
                                <div class="index-title">secret ranks</div>
                                <div class="index-items" id="secretRanksIndexItems"></div>
                            </div>
                            <div class="index-category" onclick="toggleIndexCategory('enchantsIndex')">
                                <div class="index-title">enchants</div>
                                <div class="index-items" id="enchantsIndexItems"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Bottom Stats Section -->
        <div class="bottom-stats">
            <div class="bottom-stats-title">üìä Game Statistics</div>
            <div class="stats-grid" id="bottomStatsGrid">
                <!-- Stats will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <script>
        // Helper function to format numbers
        function formatNumber(num) {
            if (num === -2932932) return "-2,932,932";
            if (num === -500) return "-500";
            if (num >= 1e9) {
                return num.toExponential(3);
            }
            return num.toLocaleString('en-US');
        }

        // Helper function to abbreviate enchant names
        function abbreviateEnchant(enchantName) {
            const abbreviations = {
                'luck i': 'L1',
                'luck ii': 'L2',
                'insanity': 'In',
                'speed i': 'S1',
                'speed ii': 'S2',
                'blitz': 'Bl',
                'insight i': 'I1',
                'insight ii': 'I2',
                'omnipotence': 'Om',
                'requiem i': 'R1',
                'requiem ii': 'R2',
                'genesis': 'Ge',
                'variant i': 'V1',
                'variant ii': 'V2',
                'unusuality': 'Un',
                'addition i': 'A1',
                'addition ii': 'A2',
                'endless': 'En',
                'greed': 'Gr',
                'patience': 'P',
                'alpha': 'Al',
                'weird i': 'W1',
                'weird ii': 'W2',
                'abnormal': 'Ab',
                'overtime': 'Ot',
                'polys blessing': 'PB',
                'delta': 'De',
                'obliteration': 'Ob',
                'avarice': 'Av'
            };
            return abbreviations[enchantName.toLowerCase()] || 'E';
        }

        // Toast notification system
        let toastNotificationsEnabled = true;
        
        function showToast(title, message, duration = 3000) {
            if (!toastNotificationsEnabled) return;
            
            const toastContainer = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.innerHTML = `
                <div class="toast-title">${title}</div>
                <div class="toast-message">${message}</div>
            `;
            
            toastContainer.appendChild(toast);
            
            // Show toast
            setTimeout(() => {
                toast.classList.add('show');
            }, 10);
            
            // Hide and remove toast after duration
            setTimeout(() => {
                toast.classList.remove('show');
                toast.classList.add('hide');
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, duration);
        }
        
        function toggleToastNotifications() {
            toastNotificationsEnabled = !toastNotificationsEnabled;
            const btn = document.getElementById('toastToggleBtn');
            if (toastNotificationsEnabled) {
                btn.textContent = 'üîî Toasts ON';
                btn.classList.add('active');
                showToast('Toasts Enabled', 'Notifications will now appear when autoroll stops.', 2000);
            } else {
                btn.textContent = 'üîï Toasts OFF';
                btn.classList.remove('active');
            }
        }

        // game constants
        const VARIANTS = [
            { name: 'normal', chance: 1, multipliesRNG: 1 },
            { name: 'shiny', chance: 10, multipliesRNG: 10 },
            { name: 'better', chance: 25, multipliesRNG: 25 },
            { name: 'spectral', chance: 50, multipliesRNG: 50 },
            { name: 'divine', chance: 100, multipliesRNG: 100 },
            { name: 'chromatic', chance: 250, multipliesRNG: 250 },
            { name: 'inverted', chance: 500, multipliesRNG: 500 },
            { name: 'defined', chance: 1000, multipliesRNG: 1000 },
            { name: 'mega', chance: 5000, multipliesRNG: 5000 },
            { name: 'myriad', chance: 10000, multipliesRNG: 10000 },
            { name: 'obscure', chance: 33333, multipliesRNG: 33333 },
            { name: 'universal', chance: 50000, multipliesRNG: 50000 },
            { name: 'ultimate', chance: 100000, multipliesRNG: 100000 },
            { name: 'mono', chance: 111111, multipliesRNG: 111111 },
            { name: 'micro', chance: 175000, multipliesRNG: 175000 },
            { name: 'super', chance: 250000, multipliesRNG: 250000 },
            { name: 'bygone', chance: 333333, multipliesRNG: 333333 },
            { name: 'overseer', chance: 500000, multipliesRNG: 500000 },
            { name: 'void', chance: 1e6, multipliesRNG: 1e6 }
        ];

        const RANKS = [
            { name: 'common', min: 1, max: 5 },
            { name: 'rare', min: 5, max: 25 },
            { name: 'decent', min: 25, max: 50 },
            { name: 'natural', min: 50, max: 100 },
            { name: 'exceptional', min: 100, max: 250 },
            { name: 'eclipse', min: 250, max: 500 },
            { name: 'mythic', min: 500, max: 1000 },
            { name: 'divine', min: 1000, max: 5000 },
            { name: 'extraordinary', min: 5000, max: 10000 },
            { name: 'unreal', min: 10000, max: 50000 },
            { name: 'eternal', min: 50000, max: 100000 },
            { name: 'iridescence', min: 100000, max: 500000 },
            { name: 'zeta', min: 500000, max: 1000000 },
            { name: 'fantasy', min: 1000000, max: 2015510 },
            { name: 'giant', min: 2015510, max: 5000000 },
            { name: 'ultimate', min: 5000000, max: 1e7 },
            { name: 'apex', min: 1e7, max: 5e7 },
            { name: 'omega', min: 5e7, max: 1e8 },
            { name: 'insane', min: 1e8, max: 2.5e8 },
            { name: 'colossal', min: 2.5e8, max: 777777777 },
            { name: 'gargantuan', min: 777777777, max: 1e9 },
            { name: 'hyper', min: 1e9, max: 1e12 },
            { name: 'insurmountable', min: 1e12, max: 1e15 },
            { name: '(infinitude)', min: 1e15, max: 1e18 },
            { name: 'Almighty', min: 1e18, max: Infinity }
        ];

        const SECRETS = [
            { name: 'terrible', chance: 2500 },
            { name: 'weird', chance: 10000 },
            { name: 'best', chance: 20000 },
            { name: 'invisible', chance: 35300 },
            { name: 'grand', chance: 77777 },
            { name: 'defined', chance: 100000 },
            { name: '?!?!?', chance: 250000 },
            { name: 'nil', chance: 500000 },
            { name: 'infinity', chance: 1000000 },
            { name: 'imaginary', chance: 2500000 },
            { name: 'poly', chance: 5000000 },
            { name: ' ', chance: 7777777.777 },
            { name: 'evil rng !!!', chance: 9999999.99 },
            { name: 'ephermal', chance: 1e7 },
            { name: 'nuclear', chance: 25000000 },
            { name: 'theoretical', chance: 40000000 },
            { name: 'oblivion', chance: 66666666.66 },
            { name: '?!?what?!?', chance: 75000000 },
            { name: 'how', chance: 1e8 },
            { name: 'mini', chance: 5e8 },
            { name: 'everlasting', chance: 575265750 },
            { name: 'infernal', chance: 7.5e8 },
            { name: 'colossium', chance: 1e9 },
            { name: 'doombringer', chance: 2.5e9 },
            { name: 'astral', chance: 3333333333.33 },
            { name: 'epsilon', chance: 5e9 },
            { name: 'solar', chance: 100000 },
            { name: 'poly¬≤', chance: 333333 },
            { name: 'NULL', chance: 229172 },
            { name: 'Completionist', chance: 1000000 },
            { name: 'ahur yp', chance: 694200 } // NEW SECRET RANK - fixed chance, unaffected by boosts
        ];

        const ENCHANT_TYPES = [
            { name: 'luck i', type: 'luck', value: 5, color: '#90ee90', chance: 1/1.5, priority: 1 },
            { name: 'luck ii', type: 'luck', value: 10, color: '#00ff00', chance: 1/5, priority: 2 },
            { name: 'insanity', type: 'luck', value: 50, color: '#00aa00', chance: 1/12500, priority: 3 },
            { name: 'speed i', type: 'speed', value: 0.25, color: '#87ceeb', chance: 1/2.5, priority: 1 },
            { name: 'speed ii', type: 'speed', value: 0.5, color: '#1e90ff', chance: 1/10, priority: 2 },
            { name: 'blitz', type: 'speed', value: 75, color: '#0066cc', chance: 1/7500, priority: 3 },
            { name: 'insight i', type: 'secret', value: 5, color: '#9370db', chance: 1/10, priority: 1 },
            { name: 'insight ii', type: 'secret', value: 25, color: '#8a2be2', chance: 1/50, priority: 2 },
            { name: 'omnipotence', type: 'secret', value: 125, color: '#6a0dad', chance: 1/25000, priority: 3 },
            { name: 'requiem i', type: 'requiem', value: 1, color: '#ff4500', chance: 1/500, priority: 1 },
            { name: 'requiem ii', type: 'requiem', value: 2, color: '#dc143c', chance: 1/10000, priority: 2 },
            { name: 'genesis', type: 'requiem', value: 3, color: '#8b0000', chance: 1/10000000, priority: 3 },
            { name: 'variant i', type: 'variant', value: 0.5, color: '#ffc0cb', chance: 1/25, priority: 1 },
            { name: 'variant ii', type: 'variant', value: 2.5, color: '#ff69b4', chance: 1/100, priority: 2 },
            { name: 'unusuality', type: 'variant', value: 20, color: '#ff1493', chance: 1/33333, priority: 3 },
            { name: 'addition i', type: 'addition', value: 1, color: '#ffaa00', chance: 1/25, priority: 1 },
            { name: 'addition ii', type: 'addition', value: 2, color: '#ff8800', chance: 1/75, priority: 2 },
            { name: 'endless', type: 'addition', value: 5, color: '#ff6600', chance: 1/5000, priority: 3 },
            { name: 'greed', type: 'greed', value: 1, color: '#ffd700', chance: 1/60, priority: 1 },
            { name: 'patience', type: 'patience', value: 1, color: '#00ced1', chance: 1/75, priority: 1 },
            { name: 'alpha', type: 'alpha', value: 1, color: '#00ffff', chance: 1/125, priority: 4 },
            { name: 'weird i', type: 'weird', value: 1.2, color: '#ff00ff', chance: 1/500, priority: 1 },
            { name: 'weird ii', type: 'weird', value: 2.5, color: '#cc00cc', chance: 1/2500, priority: 2 },
            { name: 'abnormal', type: 'weird', value: 12.5, color: '#990099', chance: 1/333333, priority: 3 },
            { name: 'overtime', type: 'overtime', baseLuck: 0.001, baseSpeed: 0.001, baseVariant: 0.001, baseSecret: 0.001, 
              currentLuck: 0.001, currentSpeed: 0.001, currentVariant: 0.001, currentSecret: 0.001, color: '#32CD32', chance: 1/5725652.5, priority: 1 },
            { name: 'polys blessing', type: 'blessing', value: 0, color: '#FFD700', chance: 1/500000, priority: 5 },
            { name: 'delta', type: 'delta', value: 10, color: '#FF6347', chance: 1/89000, priority: 6 },
            { name: 'obliteration', type: 'obliteration', value: 1, color: '#000000', chance: 1/750000, priority: 7 },
            { name: 'avarice', type: 'avarice', bulk: 20, luck: -100, speed: -3, variant: -25, secret: -12.5, color: '#964B00', chance: 1/25000, priority: 8 }
        ];

        // SPINNER REWARDS
        const SPINNER_REWARDS = [
            { name: 'luck ii', type: 'luck', value: 10, color: '#00ff00', weight: 16000 },
            { name: 'speed ii', type: 'speed', value: 0.5, color: '#1e90ff', weight: 14000 },
            { name: 'endless', type: 'addition', value: 5, color: '#ff6600', weight: 8000 },
            { name: 'requiem ii', type: 'requiem', value: 2, color: '#dc143c', weight: 6000 },
            { name: 'insanity', type: 'luck', value: 50, color: '#00aa00', weight: 4000 },
            { name: 'weird ii', type: 'weird', value: 2.5, color: '#cc00cc', weight: 3200 },
            { name: 'blitz', type: 'speed', value: 75, color: '#0066cc', weight: 2000 },
            { name: 'combo', type: 'combo', value: 1, color: '#ff00ff', weight: 20000 },
            { name: 'genesis', type: 'requiem', value: 3, color: '#8b0000', weight: 1 }
        ];

        // game state
        let polycoin = 0;
        let bestRoll = 0;
        let totalRolls = 0;
        let rollCoins = 0;
        let tickets = 0;
        let bulkLevel = 1;
        let bulkCost = 100;
        let luckLevel = 0;
        let luckCost = 10;
        let secretLevel = 0;
        let secretCost = 50;
        let speedLevel = 0;
        let speedCost = 50;
        let invLevel = 0;
        let invCost = 0;
        let enchantLuckLevel = 0;
        let enchantLuckCost = 30;
        let variantLuckLevel = 0;
        let variantLuckCost = 50;
        let minSpeedUpgrades = 0;
        let ticketProdLevel = 0;
        let ticketProdCost = 50;
        let spinnerUnlocked = false;
        let isRolling = false;
        let isAutorolling = false;
        let autorollInterval = null;
        let ticketInterval = null;
        let inventory = [];
        let enchantOrbs = [];
        let equippedOrb = null;
        let pendingRolls = [];
        let selectedSlotIndex = -1;
        let discovered = {
            variants: new Set(),
            ranks: new Set(),
            secrets: new Set(),
            enchants: new Set()
        };
        let cooldownThreshold = 0;
        let cooldownTime = 3;
        let pauseRNGThreshold = 0;
        let pauseSecretRarityThreshold = 0;
        let pauseEnchantRarityThreshold = 0;
        let overtimeRolls = {};
        let rollNumber = 0;
        let currentRollAcceptedCount = 0;
        let currentRollGeneratedRolls = [];
        let acceptableSlots = [];
        
        // NEW UPGRADE VARIABLES
        let eterniumLevel = 0;
        let eterniumCost = 1e12;
        let ultimatiplierLevel = 0;
        let ultimatiplierCost = 100;
        
        // FIXED: Initialize gameStartTime here at the top
        let gameStartTime = Date.now();
        
        // Variables for centering when autoroll stops
        let pausedSlotIndex = -1;

        // Drag scrolling variables
        let isDragging = false;
        let startX;
        let scrollLeft;

        // Completionist animation interval
        let completionistInterval = null;
        let completionistFontIndex = 0;
        const completionistFonts = [
            '', // default
            'font-fantasy',
            'font-giant',
            'font-ultimate',
            'font-apex',
            'font-omega',
            'font-insane',
            'font-colossal',
            'font-gargantuan',
            'font-hyper',
            'font-insurmountable',
            'font-infinitude',
            'font-almighty'
        ];

        // Get font for rank name
        function getRankFont(rankName) {
            if (rankName === 'NULL') return 'null-rank';
            if (rankName === 'ahur yp') return 'font-almighty'; // Use almighty font for ahur yp
            switch(rankName.toLowerCase()) {
                case 'fantasy': return 'font-fantasy';
                case 'giant': return 'font-giant';
                case 'ultimate': return 'font-ultimate';
                case 'apex': return 'font-apex';
                case 'omega': return 'font-omega';
                case 'insane': return 'font-insane';
                case 'colossal': return 'font-colossal';
                case 'gargantuan': return 'font-gargantuan';
                case 'hyper': return 'font-hyper';
                case 'insurmountable': return 'font-insurmountable';
                case '(infinitude)': return 'font-infinitude';
                case 'almighty': return 'font-almighty';
                default: return '';
            }
        }

        // Get index font class for rank name
        function getIndexRankFont(rankName) {
            if (rankName === 'NULL') return 'null-rank';
            if (rankName === 'ahur yp') return 'rank-almighty'; // Use almighty font for ahur yp
            switch(rankName.toLowerCase()) {
                case 'fantasy': return 'rank-fantasy';
                case 'giant': return 'rank-giant';
                case 'ultimate': return 'rank-ultimate';
                case 'apex': return 'rank-apex';
                case 'omega': return 'rank-omega';
                case 'insane': return 'rank-insane';
                case 'colossal': return 'rank-colossal';
                case 'gargantuan': return 'rank-gargantuan';
                case 'hyper': return 'rank-hyper';
                case 'insurmountable': return 'rank-insurmountable';
                case '(infinitude)': return 'rank-infinitude';
                case 'almighty': return 'rank-almighty';
                default: return '';
            }
        }

        // Get display text for high RNG values
        function getRNGDisplayText(rng, isSecret = false, secretChance = 0) {
            if (rng === -500) return "-500";
            if (rng === -2932932) return "-2,932,932";
            
            if (isSecret && secretChance >= 1e6) {
                return "?????";
            }
            
            if (rng >= 1e27) return "impossible";
            if (rng >= 1e24) return "insane";
            if (rng >= 1e21) return "!?WTF?!";
            if (rng >= 1e18) return "how";
            if (rng >= 1e15) return "?!?!?";
            if (rng >= 1e12) return "!";
            if (rng >= 1e9) return "?????";
            return null;
        }

        // Check if RNG should trigger obfuscation animation
        function shouldObfuscate(rng) {
            return rng >= 1e9;
        }

        // Dark mode toggle
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            const button = document.querySelector('.dark-mode-toggle');
            button.textContent = document.body.classList.contains('dark-mode') ? '‚òÄÔ∏è Light Mode' : 'üåô Dark Mode';
            localStorage.setItem('darkMode', document.body.classList.contains('dark-mode'));
        }

        // Initialize dark mode
        if (localStorage.getItem('darkMode') === 'true') {
            document.body.classList.add('dark-mode');
            document.querySelector('.dark-mode-toggle').textContent = '‚òÄÔ∏è Light Mode';
        }

        // Drag scrolling functionality
        function initDragScrolling() {
            const viewport = document.getElementById('rollerViewport');
            
            viewport.addEventListener('mousedown', (e) => {
                isDragging = true;
                startX = e.pageX - viewport.offsetLeft;
                scrollLeft = viewport.scrollLeft;
                viewport.classList.add('dragging');
                e.preventDefault();
            });
            
            viewport.addEventListener('mouseleave', () => {
                isDragging = false;
                viewport.classList.remove('dragging');
            });
            
            viewport.addEventListener('mouseup', () => {
                isDragging = false;
                viewport.classList.remove('dragging');
            });
            
            viewport.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                e.preventDefault();
                const x = e.pageX - viewport.offsetLeft;
                const walk = (x - startX) * 2;
                viewport.scrollLeft = scrollLeft - walk;
            });
            
            // Touch events for mobile
            viewport.addEventListener('touchstart', (e) => {
                isDragging = true;
                startX = e.touches[0].pageX - viewport.offsetLeft;
                scrollLeft = viewport.scrollLeft;
                viewport.classList.add('dragging');
            });
            
            viewport.addEventListener('touchend', () => {
                isDragging = false;
                viewport.classList.remove('dragging');
            });
            
            viewport.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const x = e.touches[0].pageX - viewport.offsetLeft;
                const walk = (x - startX) * 2;
                viewport.scrollLeft = scrollLeft - walk;
            });
        }

        // Start completionist animation
        function startCompletionistAnimation() {
            if (completionistInterval) clearInterval(completionistInterval);
            
            completionistInterval = setInterval(() => {
                completionistFontIndex = (completionistFontIndex + 1) % completionistFonts.length;
                
                // Update all completionist slots
                const completionistSlots = document.querySelectorAll('.slot .slot-rank.completionist-rank');
                completionistSlots.forEach(rankEl => {
                    const slot = rankEl.closest('.slot');
                    if (slot) {
                        // Remove all font classes
                        completionistFonts.forEach(font => {
                            if (font) slot.classList.remove(font);
                        });
                        // Add current font class
                        const currentFont = completionistFonts[completionistFontIndex];
                        if (currentFont) slot.classList.add(currentFont);
                        
                        // Also add animation class to slot
                        slot.classList.add('completionist-animating');
                    }
                });
                
                // Update completionist items in inventory
                const completionistInventoryItems = document.querySelectorAll('.inventory-item .inventory-details span[style*="color: rgb(0, 255, 255)"]');
                completionistInventoryItems.forEach(span => {
                    const color = getRNGColorForFontIndex(completionistFontIndex);
                    span.style.color = color;
                });
                
                // Update completionist items in index
                const completionistIndexItems = document.querySelectorAll('.index-item.completionist-index');
                completionistIndexItems.forEach(item => {
                    const color = getRNGColorForFontIndex(completionistFontIndex);
                    item.style.color = color;
                });
                
            }, 10); // Every 10ms
        }

        // Get RNG color for completionist font index
        function getRNGColorForFontIndex(index) {
            const colors = [
                '#aad7e6', // default/common
                '#ff69b4', // fantasy
                '#ff69b4', // giant
                '#ff69b4', // ultimate
                '#ff69b4', // apex
                '#ff69b4', // omega
                '#ff69b4', // insane
                '#ff69b4', // colossal
                '#ff69b4', // gargantuan
                '#ff69b4', // hyper
                '#ff69b4', // insurmountable
                '#ff69b4', // infinitude
                '#ff69b4'  // almighty
            ];
            return colors[index % colors.length];
        }

        // load game on start
        loadGame();

        function toggleSection(sectionId) {
            const content = document.getElementById(sectionId);
            if (content) {
                content.classList.toggle('open');
            }
        }

        function toggleIndexCategory(categoryId) {
            const title = document.querySelector(`[onclick*="${categoryId}"] .index-title`);
            const items = document.getElementById(categoryId + 'Items');
            if (title && items) {
                title.classList.toggle('collapsed');
                items.classList.toggle('collapsed');
            }
        }

        function toggleAutoroll() {
            const btn = document.getElementById('autorollBtn');
            if (isAutorolling) {
                clearInterval(autorollInterval);
                isAutorolling = false;
                btn.textContent = '‚ñ∂Ô∏è Start Autoroll';
                btn.classList.remove('paused');
                btn.classList.add('stopped');
            } else {
                isAutorolling = true;
                btn.textContent = '‚è∏Ô∏è Pause Autoroll';
                btn.classList.remove('stopped');
                btn.classList.add('paused');
                
                autorollInterval = setInterval(() => {
                    if (!isRolling) {
                        roll();
                    }
                }, 100);
            }
        }

        function getRNGColor(rng, rankName) {
            if (rankName === 'NULL') return 'linear-gradient(90deg, black, gray, white, gray, black)';
            if (rankName === 'solar') return 'orange';
            if (rankName === 'poly¬≤') return '#FF00FF';
            if (rankName === 'Completionist') return '#00ffff';
            if (rankName === 'ahur yp') return '#9b30ff'; // Purple color for ahur yp
            if (rng < 1000) return '#aad7e6';
            if (rng < 10000) return '#ffc0cb';
            if (rng < 100000) return '#90ee90';
            if (rng < 1000000) return '#9370db';
            if (rng < 10000000) return 'linear-gradient(90deg, #ff0000, #ffffff)';
            if (rng < 100000000) return 'linear-gradient(90deg, #00ffff, #ffffff)';
            if (rng < 1000000000) return 'linear-gradient(90deg, #000000, #8b0000)';
            if (rng < 10000000000) return 'linear-gradient(25deg, #4ef542, #ffffff)';
            if (rng < 100000000000) return 'linear-gradient(45deg, #ff00ff, #00ffff, #ffffff)';
            if (rng < 1000000000000) return 'linear-gradient(135deg, #ff0000, #ff9900, #ffff00, #ffffff)';
            if (rng < 10000000000000) return 'linear-gradient(90deg, #0000ff, #00ff00, #ffff00, #ffffff)';
            if (rng < 100000000000000) return 'linear-gradient(120deg, #8b00ff, #ff00ff, #00ffff, #ffffff)';
            if (rng < 1000000000000000) return 'linear-gradient(180deg, #ff0000, #000000, #00ff00, #ffffff)';
            if (rng < 10000000000000000) return 'linear-gradient(225deg, #00ffff, #000000, #ffff00, #ffffff)';
            if (rng < 100000000000000000) return 'linear-gradient(270deg, #ff0000, #00ff00, #0000ff, #ffffff)';
            return 'linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3)';
        }

        function getInventoryTier(finalRng) {
            if (finalRng >= 1 && finalRng < 1000) return { stars: 1, name: 'Common', color: 'white' };
            if (finalRng < 10000) return { stars: 2, name: 'Decent', color: 'yellow' };
            if (finalRng < 100000) return { stars: 3, name: 'Rare', color: 'blue' };
            if (finalRng < 1000000) return { stars: 4, name: 'Good', color: 'cyan' };
            if (finalRng < 100000000) return { stars: 5, name: 'Unordinary', color: 'orange' };
            if (finalRng < 1000000000) return { stars: 6, name: 'DAMN', color: 'pink' };
            if (finalRng < 100000000000) return { stars: 7, name: 'Insane', color: 'lime' };
            if (finalRng < 1000000000000) return { stars: 8, name: 'How', color: 'gray-white-gradient' };
            if (finalRng < 1e15) return { stars: 9, name: 'DAWG', color: 'yellow-white-gradient' };
            if (finalRng < 1e18) return { stars: 10, name: 'Lol', color: 'purple-violet-gradient' };
            if (finalRng < 1e21) return { stars: 11, name: 'STOP', color: 'red-black-gradient' };
            if (finalRng < 1e24) return { stars: 12, name: 'WTF', color: 'pink-purple-violet-gradient' };
            if (finalRng < 1e27) return { stars: 13, name: 'insane', color: 'cyan-darkblue-cyan-gradient' };
            return { stars: 14, name: 'impossible', color: 'white-black-gradient' };
        }

        function calculateRNG() {
            const luck = luckLevel * 0.5 + getTotalEnchantLuck();
            let rng = Math.random() ** (-1.3 - (luck * 0.01));
            
            // Apply Ultimatiplier chance
            if (ultimatiplierLevel > 0) {
                const ultimatiplierChance = ultimatiplierLevel * 0.0005; // 0.05% per level
                if (Math.random() < ultimatiplierChance) {
                    rng *= 5; // x5 RNG
                }
            }
            
            return Math.max(1, rng);
        }

        function applyStarBonus(value, stars) {
            if (!stars || stars === 0) return value;
            return value * (1 + (stars * 0.2));
        }

        function getTotalEnchantLuck() {
            let total = 0;
            if (!equippedOrb) return total;
            
            const stars = equippedOrb.stars || 0;
            
            equippedOrb.enchants.forEach(enchant => {
                if (enchant.type === 'luck') total += applyStarBonus(enchant.value, stars);
                if (enchant.type === 'alpha') total += applyStarBonus(0.25, stars);
                if (enchant.type === 'delta') total += applyStarBonus(2.5, stars);
                if (enchant.type === 'obliteration') total += applyStarBonus(500, stars);
                if (enchant.type === 'avarice') total += applyStarBonus(enchant.luck, stars);
                if (enchant.type === 'requiem') {
                    if (enchant.value === 1) total += applyStarBonus(5, stars);
                    else if (enchant.value === 2) total += applyStarBonus(10, stars);
                    else if (enchant.value === 3) total += applyStarBonus(50, stars);
                }
                if (enchant.type === 'greed') total -= applyStarBonus(20, stars);
                if (enchant.type === 'patience') total += applyStarBonus(100, stars);
                if (enchant.type === 'overtime') {
                    const rolls = (enchant.rollsWithOvertime || 0);
                    let factor = 1.0;
                    if (rolls >= 10000) factor = 0.0001;
                    else if (rolls >= 7500) factor = 0.25;
                    else if (rolls >= 5000) factor = 0.5;
                    else if (rolls >= 1000) factor = 0.75;
                    
                    total += applyStarBonus(enchant.currentLuck * factor, stars);
                }
            });
            
            return total;
        }

        function getTotalEnchantSecret() {
            let total = 0;
            if (!equippedOrb) return total;
            
            const stars = equippedOrb.stars || 0;
            
            equippedOrb.enchants.forEach(enchant => {
                if (enchant.type === 'secret') total += applyStarBonus(enchant.value, stars);
                if (enchant.type === 'alpha') total += applyStarBonus(0.5, stars);
                if (enchant.type === 'delta') total += applyStarBonus(5, stars);
                if (enchant.type === 'obliteration') total += applyStarBonus(20, stars);
                if (enchant.type === 'avarice') total += applyStarBonus(enchant.secret, stars);
                if (enchant.type === 'requiem') {
                    if (enchant.value === 1) total += applyStarBonus(5, stars);
                    else if (enchant.value === 2) total += applyStarBonus(25, stars);
                    else if (enchant.value === 3) total += applyStarBonus(125, stars);
                }
                if (enchant.type === 'overtime') {
                    const rolls = (enchant.rollsWithOvertime || 0);
                    let factor = 1.0;
                    if (rolls >= 10000) factor = 0.0001;
                    else if (rolls >= 7500) factor = 0.25;
                    else if (rolls >= 5000) factor = 0.5;
                    else if (rolls >= 1000) factor = 0.75;
                    
                    total += applyStarBonus(enchant.currentSecret * factor, stars);
                }
            });
            
            return total;
        }

        function getTotalEnchantSpeed() {
            let total = 0;
            if (!equippedOrb) return total;
            
            const stars = equippedOrb.stars || 0;
            
            equippedOrb.enchants.forEach(enchant => {
                if (enchant.type === 'speed') total += applyStarBonus(enchant.value, stars);
                if (enchant.type === 'alpha') total -= applyStarBonus(0.05, stars);
                if (enchant.type === 'delta') total -= applyStarBonus(0.5, stars);
                if (enchant.type === 'obliteration') total += applyStarBonus(2, stars);
                if (enchant.type === 'avarice') total += applyStarBonus(enchant.speed, stars);
                if (enchant.type === 'requiem') {
                    if (enchant.value === 1) total += applyStarBonus(0.25, stars);
                    else if (enchant.value === 2) total += applyStarBonus(0.5, stars);
                    else if (enchant.value === 3) total += applyStarBonus(75, stars);
                }
                if (enchant.type === 'greed') total -= applyStarBonus(0.7, stars);
                if (enchant.type === 'patience') total -= applyStarBonus(25, stars);
                if (enchant.type === 'overtime') {
                    const rolls = (enchant.rollsWithOvertime || 0);
                    let factor = 1.0;
                    if (rolls >= 10000) factor = 0.0001;
                    else if (rolls >= 7500) factor = 0.25;
                    else if (rolls >= 5000) factor = 0.5;
                    else if (rolls >= 1000) factor = 0.75;
                    
                    total += applyStarBonus(enchant.currentSpeed * factor, stars);
                }
            });
            
            return total;
        }

        function getTotalEnchantVariant() {
            let total = variantLuckLevel * 0.05;
            if (!equippedOrb) return total;
            
            const stars = equippedOrb.stars || 0;
            
            equippedOrb.enchants.forEach(enchant => {
                if (enchant.type === 'variant') total += applyStarBonus(enchant.value, stars);
                if (enchant.type === 'alpha') total += applyStarBonus(0.125, stars);
                if (enchant.type === 'delta') total += applyStarBonus(1.25, stars);
                if (enchant.type === 'obliteration') total += applyStarBonus(17.5, stars);
                if (enchant.type === 'avarice') total += applyStarBonus(enchant.variant, stars);
                if (enchant.type === 'requiem') {
                    if (enchant.value === 1) total += applyStarBonus(0.5, stars);
                    else if (enchant.value === 2) total += applyStarBonus(2.5, stars);
                    else if (enchant.value === 3) total += applyStarBonus(20, stars);
                }
                if (enchant.type === 'patience') total += applyStarBonus(5, stars);
                if (enchant.type === 'overtime') {
                    const rolls = (enchant.rollsWithOvertime || 0);
                    let factor = 1.0;
                    if (rolls >= 10000) factor = 0.0001;
                    else if (rolls >= 7500) factor = 0.25;
                    else if (rolls >= 5000) factor = 0.5;
                    else if (rolls >= 1000) factor = 0.75;
                    
                    total += applyStarBonus(enchant.currentVariant * factor, stars);
                }
            });
            
            return total;
        }

        function getTotalEnchantLuckBonus() {
            let total = enchantLuckLevel * 0.05;
            if (!equippedOrb) return total;
            
            const stars = equippedOrb.stars || 0;
            
            equippedOrb.enchants.forEach(enchant => {
                if (enchant.type === 'weird') total += applyStarBonus(enchant.value, stars);
            });
            
            return total;
        }

        function getTotalBulkRolls() {
            let total = Math.min(bulkLevel, 100);
            
            if (!equippedOrb) return total;
            
            equippedOrb.enchants.forEach(enchant => {
                if (enchant.type === 'addition') total += enchant.value;
                if (enchant.type === 'avarice') total += enchant.bulk;
                if (enchant.type === 'greed') total += 2;
                if (enchant.type === 'patience') total += 3;
                if (enchant.type === 'obliteration') {
                    total = 1; // Sets bulk to 1
                }
                if (enchant.type === 'requiem') {
                    if (enchant.value === 1) total += 1;
                    else if (enchant.value === 2) total += 2;
                    else if (enchant.value === 3) total += 5;
                }
            });
            
            // Check for obliteration enchant which sets bulk to 1
            const hasObliteration = equippedOrb.enchants.some(e => e.type === 'obliteration');
            if (hasObliteration) {
                total = 1;
            }
            
            // Apply Eternium chance for double bulk
            if (eterniumLevel > 0) {
                const eterniumChance = eterniumLevel * 0.05; // 5% per level
                if (Math.random() < eterniumChance) {
                    total *= 2;
                }
            }
            
            return Math.min(total, 200); // Cap at 200
        }

        function getRank(rng) {
            for (let i = RANKS.length - 1; i >= 0; i--) {
                if (rng >= RANKS[i].min) {
                    return RANKS[i].name;
                }
            }
            return RANKS[0].name;
        }

        function getVariant() {
            const variantLuck = getTotalEnchantVariant();
            for (let i = VARIANTS.length - 1; i >= 0; i--) {
                const adjustedChance = VARIANTS[i].chance / (1 + variantLuck);
                const random = Math.random();
                if (random <= 1 / adjustedChance) {
                    return VARIANTS[i];
                }
            }
            return VARIANTS[0];
        }

        function checkSecret(baseRng, hasPolyBlessing) {
            const secretLuck = secretLevel * 0.2 + getTotalEnchantSecret();
            const random = Math.random();
            
            let allNormalRanksDiscovered = true;
            for (const rank of RANKS) {
                if (!discovered.ranks.has(rank.name)) {
                    allNormalRanksDiscovered = false;
                    break;
                }
            }
            
            // Check for ahur yp first (fixed chance, unaffected by boosts)
            if (random <= 1/694200) {
                return 'ahur yp';
            }
            
            // Check for NULL first (true RNG secret, always replaces)
            if (random <= 1/229172) {
                return 'NULL';
            }
            
            // Check for poly¬≤
            if (hasPolyBlessing && random <= 1/333333) {
                return 'poly¬≤';
            }
            
            const currentRank = getRank(baseRng);
            if (currentRank === 'eclipse' && random <= 1/100000) {
                return 'solar';
            }
            
            // Completionist is always rollable once all normal ranks are discovered
            if (allNormalRanksDiscovered && random <= 1/1000000) {
                return 'Completionist';
            }
            
            for (let i = SECRETS.length - 1; i >= 0; i--) {
                if (SECRETS[i].name === 'Completionist' || SECRETS[i].name === 'solar' || 
                    SECRETS[i].name === 'poly¬≤' || SECRETS[i].name === 'NULL' || 
                    SECRETS[i].name === 'ahur yp') continue;
                
                const adjustedChance = SECRETS[i].chance / (1 + secretLuck);
                if (random <= 1 / adjustedChance) {
                    return SECRETS[i].name;
                }
            }
            return null;
        }

        function shouldOverrideEnchant(enchantName) {
            const overrideExceptions = ['requiem i', 'requiem ii', 'genesis', 'blitz', 'omnipotence', 'endless', 'abnormal', 'unusuality', 'overtime', 'polys blessing', 'delta', 'obliteration', 'avarice'];
            return !overrideExceptions.includes(enchantName.toLowerCase());
        }

        function generateEnchants(baseRng) {
            if (baseRng < 500) return [];
            
            const generated = {};
            const enchantLuck = getTotalEnchantLuckBonus();
            
            const deltaChance = ENCHANT_TYPES.find(e => e.name === 'delta').chance * (1 + enchantLuck);
            let hasDelta = false;
            if (Math.random() <= deltaChance) {
                hasDelta = true;
                const deltaEnchant = ENCHANT_TYPES.find(e => e.name === 'delta');
                generated['delta'] = {
                    name: deltaEnchant.name,
                    type: deltaEnchant.type,
                    value: deltaEnchant.value,
                    color: deltaEnchant.color,
                    priority: deltaEnchant.priority
                };
            }
            
            const alphaChance = ENCHANT_TYPES.find(e => e.name === 'alpha').chance * (1 + enchantLuck);
            let hasAlpha = false;
            if (!hasDelta && Math.random() <= alphaChance) {
                hasAlpha = true;
                const alphaEnchant = ENCHANT_TYPES.find(e => e.name === 'alpha');
                generated['alpha'] = {
                    name: alphaEnchant.name,
                    type: alphaEnchant.type,
                    value: alphaEnchant.value,
                    color: alphaEnchant.color,
                    priority: alphaEnchant.priority
                };
            }
            
            const obliterationChance = ENCHANT_TYPES.find(e => e.name === 'obliteration').chance * (1 + enchantLuck);
            let hasObliteration = false;
            if (Math.random() <= obliterationChance) {
                hasObliteration = true;
                const obliterationEnchant = ENCHANT_TYPES.find(e => e.name === 'obliteration');
                generated['obliteration'] = {
                    name: obliterationEnchant.name,
                    type: obliterationEnchant.type,
                    value: obliterationEnchant.value,
                    color: obliterationEnchant.color,
                    priority: obliterationEnchant.priority
                };
            }
            
            const avariceChance = ENCHANT_TYPES.find(e => e.name === 'avarice').chance * (1 + enchantLuck);
            let hasAvarice = false;
            if (Math.random() <= avariceChance) {
                hasAvarice = true;
                const avariceEnchant = ENCHANT_TYPES.find(e => e.name === 'avarice');
                generated['avarice'] = {
                    name: avariceEnchant.name,
                    type: avariceEnchant.type,
                    bulk: avariceEnchant.bulk,
                    luck: avariceEnchant.luck,
                    speed: avariceEnchant.speed,
                    variant: avariceEnchant.variant,
                    secret: avariceEnchant.secret,
                    color: avariceEnchant.color,
                    priority: avariceEnchant.priority
                };
            }
            
            ENCHANT_TYPES.forEach(enchant => {
                if (enchant.name === 'alpha' || enchant.name === 'delta' || enchant.name === 'obliteration' || enchant.name === 'avarice') return;
                
                if ((hasAlpha || hasDelta || hasObliteration || hasAvarice) && shouldOverrideEnchant(enchant.name)) {
                    return;
                }
                
                const adjustedChance = enchant.chance * (1 + enchantLuck);
                if (Math.random() <= adjustedChance) {
                    if (enchant.name === 'overtime') {
                        generated['overtime'] = {
                            name: enchant.name,
                            type: enchant.type,
                            baseLuck: enchant.baseLuck,
                            baseSpeed: enchant.baseSpeed,
                            baseVariant: enchant.baseVariant,
                            baseSecret: enchant.baseSecret,
                            currentLuck: enchant.baseLuck,
                            currentSpeed: enchant.baseSpeed,
                            currentVariant: enchant.baseVariant,
                            currentSecret: enchant.baseSecret,
                            color: enchant.color,
                            priority: enchant.priority
                        };
                    } else if (!generated[enchant.type] || generated[enchant.type].priority < enchant.priority) {
                        generated[enchant.type] = {
                            name: enchant.name,
                            type: enchant.type,
                            value: enchant.value,
                            color: enchant.color,
                            priority: enchant.priority
                        };
                    }
                }
            });
            
            return Object.values(generated).sort((a, b) => a.type.localeCompare(b.type));
        }

        function generateStars(hasEnchants) {
            if (!hasEnchants) return 0;
            
            if (Math.random() > 1/3) return 0;
            
            const starRolls = [
                { stars: 1, chance: 1/1 },
                { stars: 2, chance: 1/3 },
                { stars: 3, chance: 1/6 },
                { stars: 4, chance: 1/9 },
                { stars: 5, chance: 1/12 }
            ];
            
            for (let i = starRolls.length - 1; i >= 0; i--) {
                if (Math.random() <= starRolls[i].chance) {
                    return starRolls[i].stars;
                }
            }
            
            return 1;
        }

        function updateSlots() {
            const container = document.getElementById('slotsContainer');
            container.innerHTML = '';
            const totalSlots = getTotalBulkRolls();
            pendingRolls = new Array(totalSlots).fill(null);
            
            // Calculate the middle section for acceptable slots - ALL slots are acceptable now
            acceptableSlots = Array.from({length: totalSlots}, (_, i) => i);
            
            // Resize roller container based on number of slots
            const rollerContainer = document.querySelector('.roller-container');
            const viewport = document.querySelector('.roller-viewport');
            
            if (totalSlots <= 20) {
                rollerContainer.style.height = '220px';
                viewport.style.height = 'calc(100% - 60px)';
            } else if (totalSlots <= 40) {
                rollerContainer.style.height = '250px';
                viewport.style.height = 'calc(100% - 60px)';
            } else {
                rollerContainer.style.height = '300px';
                viewport.style.height = '240px';
            }
            
            for (let i = 0; i < totalSlots; i++) {
                const wrapper = document.createElement('div');
                wrapper.className = 'slot-wrapper acceptable';
                wrapper.innerHTML = `
                    <div class="slot unrolled acceptable" id="slot-${i}" data-index="${i}">
                        <div class="roll-indicator">${i + 1}</div>
                        <div class="slot-variant" style="display: none;"></div>
                        <div class="slot-value">?</div>
                        <div class="slot-rank" style="display: none;"></div>
                    </div>
                    <div class="slot-buttons">
                        <button class="slot-accept-btn" onclick="event.stopPropagation(); acceptRoll(${i})">‚úì</button>
                        <button class="slot-decline-btn" onclick="event.stopPropagation(); declineRoll(${i})">‚úó</button>
                    </div>
                `;
                
                // Add click handler for the slot itself
                const slot = wrapper.querySelector('.slot');
                slot.onclick = () => selectSlot(i);
                
                container.appendChild(wrapper);
            }
        }

        function selectSlot(index) {
            document.querySelectorAll('.slot').forEach(slot => {
                slot.classList.remove('selected');
            });
            
            const slot = document.getElementById(`slot-${index}`);
            if (slot) {
                slot.classList.add('selected');
                selectedSlotIndex = index;
                showSlotDetails(index);
            }
        }

        function showSlotDetails(index) {
            const detailsContainer = document.getElementById('selectedSlotDetails');
            const roll = pendingRolls[index];
            
            if (!roll) {
                detailsContainer.innerHTML = '<div style="text-align: center; color: #666;">No roll data for this slot yet.</div>';
                detailsContainer.style.display = 'block';
                return;
            }
            
            const color = getRNGColor(roll.finalRng, roll.rank);
            let style = `color: ${color};`;
            if (color.includes('gradient')) {
                style = `background: ${color}; -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;`;
            }
            
            // Check if we should obfuscate the RNG display
            const displayText = getRNGDisplayText(roll.finalRng, roll.isSecret, roll.secretChance);
            const rngDisplay = displayText ? displayText : formatNumber(roll.finalRng);
            
            const enchantsHTML = roll.enchants && roll.enchants.length > 0 
                ? `<div><strong>Enchants:</strong> ${roll.enchants.map(e => `<span style="color: ${e.color}">${e.name}</span>`).join(', ')}</div>`
                : '';
            
            const starsHTML = roll.stars && roll.stars > 0 
                ? `<div><strong>Stars:</strong> ${'‚≠ê'.repeat(roll.stars)}</div>`
                : '';
            
            detailsContainer.innerHTML = `
                <div class="selected-slot-title">Slot ${index + 1} Details</div>
                <div class="selected-slot-info">
                    <div><strong>RNG:</strong> <span style="${style}">${rngDisplay}</span></div>
                    <div><strong>Rank:</strong> <span style="${style}">${roll.rank}</span></div>
                    <div><strong>Variant:</strong> ${roll.variant}</div>
                    <div><strong>Multiplier:</strong> x${formatNumber(Math.round(roll.finalRng/roll.baseRng))}</div>
                </div>
                ${enchantsHTML}
                ${starsHTML}
                <div class="selected-slot-actions">
                    <button class="accept-btn" onclick="acceptRoll(${index})">‚úì Accept</button>
                    <button class="decline-btn" onclick="declineRoll(${index})">‚úó Decline</button>
                </div>
            `;
            detailsContainer.style.display = 'block';
        }

        function displaySlot(index, baseRng, finalRng, rank, variant, generatedEnchants, stars, isSecret, secretChance) {
            const slot = document.getElementById(`slot-${index}`);
            if (!slot) return;
            
            // Clear previous classes
            slot.className = 'slot rolled acceptable';
            slot.classList.remove('null-secret', 'completionist-animating', 'obfuscating');
            
            // Remove all rank font classes
            const fontClasses = ['font-fantasy', 'font-giant', 'font-ultimate', 'font-apex', 
                               'font-omega', 'font-insane', 'font-colossal', 'font-gargantuan', 
                               'font-hyper', 'font-insurmountable', 'font-infinitude', 'font-almighty', 'null-rank'];
            fontClasses.forEach(fontClass => slot.classList.remove(fontClass));
            
            // Add rank-specific font
            const fontClass = getRankFont(rank);
            if (fontClass) {
                slot.classList.add(fontClass);
            }
            
            // For NULL secret, add special class
            if (rank === 'NULL') {
                slot.classList.add('null-secret');
            }
            
            const color = getRNGColor(finalRng, rank);
            let style = `color: ${color};`;
            if (color.includes('gradient')) {
                style = `background: ${color}; -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;`;
            }
            
            // Check if we should obfuscate the RNG display
            const displayText = getRNGDisplayText(finalRng, isSecret, secretChance);
            const rngDisplay = displayText ? displayText : formatNumber(finalRng);
            
            // Update slot content with proper z-index layering
            slot.innerHTML = `
                <div class="roll-indicator">${index + 1}</div>
                <div class="slot-variant">${variant}</div>
                <div class="slot-value" style="${style}">${rngDisplay}</div>
                <div class="slot-rank">${rank}</div>
            `;
            
            // Apply special styles for the rank element
            const rankEl = slot.querySelector('.slot-rank');
            if (rankEl) {
                // Set rank color to match RNG color (except for special ranks which have their own animations)
                if (rank !== 'Completionist' && rank !== 'NULL' && rank !== 'ahur yp') {
                    if (color.includes('gradient')) {
                        rankEl.style.background = color;
                        rankEl.style.webkitBackgroundClip = 'text';
                        rankEl.style.webkitTextFillColor = 'transparent';
                        rankEl.style.backgroundClip = 'text';
                    } else {
                        rankEl.style.color = color;
                    }
                }
                
                // Add special classes for special ranks
                if (rank === 'solar') {
                    rankEl.classList.add('solar-rank');
                } else if (rank === 'poly¬≤') {
                    rankEl.classList.add('poly-squared-rank');
                } else if (rank === 'NULL') {
                    rankEl.classList.add('null-rank');
                } else if (rank === 'Completionist') {
                    rankEl.classList.add('completionist-rank');
                    // Start the completionist animation for this slot
                    slot.classList.add('completionist-animating');
                } else if (rank === 'ahur yp') {
                    rankEl.classList.add('ahur-yp-rank');
                    rankEl.style.color = '#9b30ff';
                    rankEl.style.textShadow = '0 0 10px #9b30ff';
                }
            }
            
            // Apply obfuscation animation for high RNG values
            const valueEl = slot.querySelector('.slot-value');
            if (shouldObfuscate(finalRng) && !displayText) {
                valueEl.classList.add('obfuscating');
                if (rankEl && rank !== 'NULL' && rank !== 'Completionist' && rank !== 'ahur yp') {
                    rankEl.classList.add('obfuscating');
                }
            }
            
            // Add stars indicator if present
            if (stars && stars > 0) {
                let starIndicator = slot.querySelector('.slot-stars');
                if (!starIndicator) {
                    starIndicator = document.createElement('div');
                    starIndicator.className = 'slot-stars';
                    slot.appendChild(starIndicator);
                }
                starIndicator.textContent = '‚≠ê'.repeat(stars);
            }
            
            // Add enchant indicator if present
            if (generatedEnchants && generatedEnchants.length > 0) {
                let enchantIndicator = slot.querySelector('.slot-enchant');
                if (!enchantIndicator) {
                    enchantIndicator = document.createElement('div');
                    enchantIndicator.className = 'slot-enchant';
                    slot.appendChild(enchantIndicator);
                }
                // Show full enchant name or abbreviation
                const enchantNames = generatedEnchants.map(e => abbreviateEnchant(e.name)).join(',');
                enchantIndicator.textContent = enchantNames;
                enchantIndicator.title = generatedEnchants.map(e => e.name).join(', ');
                enchantIndicator.style.backgroundColor = generatedEnchants[0].color;
                
                // Adjust rank position to account for enchant indicator
                if (rankEl) {
                    rankEl.style.marginBottom = '12px'; // Make room for enchant indicator
                }
            } else {
                // Remove enchant indicator if present
                const enchantIndicator = slot.querySelector('.slot-enchant');
                if (enchantIndicator) {
                    enchantIndicator.remove();
                }
                // Reset rank position
                if (rankEl) {
                    rankEl.style.marginBottom = '';
                }
            }
            
            // Make slot clickable again
            slot.onclick = () => selectSlot(index);
        }

        function acceptRoll(index) {
            if (!pendingRolls[index]) return;
            
            const maxSlots = 10 + invLevel;
            
            // Add to inventory
            inventory.unshift({
                ...pendingRolls[index],
                rollNumber: rollNumber,
                generatedIndex: index % getTotalBulkRolls()
            });
            
            if (pendingRolls[index].enchants && pendingRolls[index].enchants.length > 0) {
                const stars = pendingRolls[index].stars || 0;
                const orb = {
                    id: Date.now() + Math.random(),
                    enchants: pendingRolls[index].enchants.map(enchant => {
                        if (enchant.type === 'overtime') {
                            return {
                                name: enchant.name,
                                type: enchant.type,
                                baseLuck: enchant.baseLuck,
                                baseSpeed: enchant.baseSpeed,
                                baseVariant: enchant.baseVariant,
                                baseSecret: enchant.baseSecret,
                                currentLuck: enchant.currentLuck,
                                currentSpeed: enchant.currentSpeed,
                                currentVariant: enchant.currentVariant,
                                currentSecret: enchant.currentSecret,
                                color: enchant.color,
                                priority: enchant.priority
                            };
                        } else if (enchant.type === 'avarice') {
                            return {
                                name: enchant.name,
                                type: enchant.type,
                                bulk: enchant.bulk,
                                luck: enchant.luck,
                                speed: enchant.speed,
                                variant: enchant.variant,
                                secret: enchant.secret,
                                color: enchant.color,
                                priority: enchant.priority
                            };
                        }
                        return { ...enchant };
                    }),
                    sourceRNG: pendingRolls[index].finalRng,
                    variant: pendingRolls[index].variant,
                    stars: stars,
                    locked: false,
                    rollsWithOvertime: 0
                };
                enchantOrbs.push(orb);
            }
            
            const slot = document.getElementById(`slot-${index}`);
            if (slot) {
                slot.innerHTML = `
                    <div class="roll-indicator">${index + 1}</div>
                    <div class="slot-variant" style="display: none;"></div>
                    <div class="slot-value" style="color: #90ee90;">‚úì</div>
                    <div class="slot-rank" style="display: none;"></div>
                `;
                slot.classList.remove('selected');
                slot.classList.remove('rolled');
                slot.classList.remove('acceptable');
                slot.classList.remove('completionist-animating', 'obfuscating');
            }
            
            // Disable the buttons for this slot
            const wrapper = slot.closest('.slot-wrapper');
            if (wrapper) {
                wrapper.classList.remove('acceptable');
                const buttons = wrapper.querySelector('.slot-buttons');
                if (buttons) {
                    buttons.style.opacity = '0.5';
                    buttons.style.pointerEvents = 'none';
                }
            }
            
            pendingRolls[index] = null;
            
            if (selectedSlotIndex === index) {
                document.getElementById('selectedSlotDetails').style.display = 'none';
                selectedSlotIndex = -1;
            }
            
            updateInventory();
            updateEnchantInventory();
            updateMergeSelects();
            updateBottomStats();
            updateUI();
            saveGame();
        }

        function declineRoll(index) {
            if (!pendingRolls[index]) return;
            
            const slot = document.getElementById(`slot-${index}`);
            if (slot) {
                slot.innerHTML = `
                    <div class="roll-indicator">${index + 1}</div>
                    <div class="slot-variant" style="display: none;"></div>
                    <div class="slot-value" style="color: #ff4444;">‚úó</div>
                    <div class="slot-rank" style="display: none;"></div>
                `;
                slot.classList.remove('selected');
                slot.classList.remove('rolled');
                slot.classList.remove('acceptable');
                slot.classList.remove('completionist-animating', 'obfuscating');
            }
            
            // Disable the buttons for this slot
            const wrapper = slot.closest('.slot-wrapper');
            if (wrapper) {
                wrapper.classList.remove('acceptable');
                const buttons = wrapper.querySelector('.slot-buttons');
                if (buttons) {
                    buttons.style.opacity = '0.5';
                    buttons.style.pointerEvents = 'none';
                }
            }
            
            pendingRolls[index] = null;
            
            if (selectedSlotIndex === index) {
                document.getElementById('selectedSlotDetails').style.display = 'none';
                selectedSlotIndex = -1;
            }
        }

        function deleteInventoryItem(index) {
            inventory.splice(index, 1);
            updateInventory();
            updateBottomStats();
            saveGame();
        }

        function deleteEnchantOrb(index) {
            if (equippedOrb && enchantOrbs[index].id === equippedOrb.id) {
                equippedOrb = null;
            }
            enchantOrbs.splice(index, 1);
            updateEnchantInventory();
            updateMergeSelects();
            updateBottomStats();
            updateUI();
            saveGame();
        }

        function equipEnchantOrb(index) {
            equippedOrb = enchantOrbs[index];
            
            if (!equippedOrb.rollsWithOvertime) {
                equippedOrb.rollsWithOvertime = 0;
            }
            
            updateEnchantInventory();
            updateBottomStats();
            updateUI();
            saveGame();
        }

        function unequipEnchantOrb() {
            equippedOrb = null;
            updateEnchantInventory();
            updateBottomStats();
            updateUI();
            saveGame();
        }

        function unmergeEnchantOrb() {
            const select1 = document.getElementById('mergeOrb1');
            const orbIndex = parseInt(select1.value);
            
            if (orbIndex === -1) {
                alert("Please select an orb to unmerge.");
                return;
            }
            
            if (rollCoins < 100000) {
                alert("You need 100,000 roll coins to unmerge an orb!");
                return;
            }
            
            const orb = enchantOrbs[orbIndex];
            if (!orb || orb.enchants.length <= 1) {
                alert("Selected orb doesn't have multiple enchants to unmerge!");
                return;
            }
            
            // Check if equipped
            if (equippedOrb && equippedOrb.id === orb.id) {
                unequipEnchantOrb();
            }
            
            rollCoins -= 100000;
            
            // Create new orbs for each enchant
            const newOrbs = orb.enchants.map(enchant => ({
                id: Date.now() + Math.random(),
                enchants: [enchant],
                sourceRNG: orb.sourceRNG,
                variant: orb.variant,
                stars: orb.stars,
                locked: false,
                rollsWithOvertime: 0
            }));
            
            // Remove the original orb
            enchantOrbs.splice(orbIndex, 1);
            
            // Add the new orbs
            enchantOrbs.push(...newOrbs);
            
            // Unlock all enchants in the index
            newOrbs.forEach(newOrb => {
                discovered.enchants.add(newOrb.enchants[0].name);
            });
            
            updateEnchantInventory();
            updateMergeSelects();
            updateIndex();
            updateBottomStats();
            updateUI();
            saveGame();
            
            alert(`Orb unmerged successfully! Created ${newOrbs.length} new orbs and unlocked all enchants.`);
        }

        function roll() {
            if (isRolling) return;
            
            isRolling = true;
            document.getElementById('rollBtn').disabled = true;
            
            // Reset accepted count for new roll
            currentRollAcceptedCount = 0;
            currentRollGeneratedRolls = [];
            pausedSlotIndex = -1;
            
            const slots = document.querySelectorAll('.slot');
            slots.forEach((slot, i) => {
                slot.innerHTML = `
                    <div class="roll-indicator">${i + 1}</div>
                    <div class="slot-variant" style="display: none;"></div>
                    <div class="slot-value">?</div>
                    <div class="slot-rank" style="display: none;"></div>
                `;
                slot.className = 'slot unrolled acceptable';
                slot.classList.remove('selected');
                slot.classList.remove('rolled');
                slot.classList.remove('null-secret');
                slot.classList.remove('completionist-animating', 'obfuscating');
                const starIndicator = slot.querySelector('.slot-stars');
                if (starIndicator) starIndicator.remove();
                const enchantIndicator = slot.querySelector('.slot-enchant');
                if (enchantIndicator) enchantIndicator.remove();
                
                // Re-enable buttons for all slots
                const wrapper = slot.closest('.slot-wrapper');
                if (wrapper) {
                    wrapper.classList.add('acceptable');
                    const buttons = wrapper.querySelector('.slot-buttons');
                    if (buttons) {
                        buttons.style.opacity = '1';
                        buttons.style.pointerEvents = 'auto';
                    }
                }
            });
            
            document.getElementById('selectedSlotDetails').style.display = 'none';
            selectedSlotIndex = -1;
            
            const baseSpeed = 3;
            const speedReduction = speedLevel * 0.1 + getTotalEnchantSpeed();
            const minRollSpeed = Math.max(0.05 - (minSpeedUpgrades * 0.01), 0.01);
            const rollSpeed = Math.max(minRollSpeed, baseSpeed - speedReduction);
            
            rollNumber++;
            
            setTimeout(() => {
                const totalDisplaySlots = getTotalBulkRolls();
                const actualBulkRolls = getTotalBulkRolls();
                let maxRoll = 0;
                let foundSecretToPause = false;
                let foundEnchantToPause = false;
                let foundRNGToPause = false;
                
                const generatedRolls = [];
                for (let i = 0; i < actualBulkRolls; i++) {
                    let baseRng = calculateRNG();
                    
                    const hasPolyBlessing = equippedOrb && equippedOrb.enchants && 
                        equippedOrb.enchants.some(e => e.name === 'polys blessing');
                    
                    let secret = checkSecret(baseRng, hasPolyBlessing);
                    let secretChance = 0;
                    if (secret) {
                        const secretObj = SECRETS.find(s => s.name === secret);
                        secretChance = secretObj ? secretObj.chance : 0;
                    }
                    
                    const variant = getVariant();
                    let finalRng;
                    if (secret === 'poly¬≤') {
                        finalRng = -2932932;
                        baseRng = -2932932;
                    } else if (secret === 'solar') {
                        baseRng *= 100000;
                        finalRng = baseRng;
                    } else if (secret === 'Completionist') {
                        finalRng = -500;
                    } else if (secret === 'NULL') {
                        finalRng = baseRng; // NULL replaces the rank but keeps RNG value
                    } else if (secret === 'ahur yp') {
                        finalRng = 694200; // Fixed TRNG value for ahur yp
                    } else {
                        finalRng = baseRng * variant.multipliesRNG;
                    }
                    
                    if (finalRng > maxRoll && finalRng > 0) maxRoll = finalRng;
                    
                    const rankName = secret || getRank(baseRng);
                    
                    discovered.variants.add(variant.name);
                    discovered.ranks.add(rankName);
                    if (secret) discovered.secrets.add(secret);
                    
                    const gain = (secret === 'Completionist' || secret === 'poly¬≤' || secret === 'NULL' || secret === 'ahur yp') ? 0 : Math.floor(Math.pow(finalRng, 0.8) * 0.75);
                    polycoin += gain;
                    rollCoins += 1;
                    totalRolls++;
                    
                    if (finalRng > bestRoll && finalRng > 0) {
                        bestRoll = finalRng;
                    }
                    
                    const generatedEnchants = generateEnchants(baseRng);
                    generatedEnchants.forEach(e => discovered.enchants.add(e.name));
                    
                    if (equippedOrb && equippedOrb.enchants) {
                        equippedOrb.enchants.forEach(enchant => {
                            if (enchant.type === 'overtime') {
                                if (!equippedOrb.rollsWithOvertime) {
                                    equippedOrb.rollsWithOvertime = 0;
                                }
                                equippedOrb.rollsWithOvertime++;
                                
                                const rolls = equippedOrb.rollsWithOvertime;
                                let factor = 1.0;
                                if (rolls >= 10000) factor = 0.0001;
                                else if (rolls >= 7500) factor = 0.25;
                                else if (rolls >= 5000) factor = 0.5;
                                else if (rolls >= 1000) factor = 0.75;
                                
                                const increment = 0.001 * factor;
                                enchant.currentLuck += increment;
                                enchant.currentSpeed += increment;
                                enchant.currentVariant += increment;
                                enchant.currentSecret += increment;
                            }
                        });
                    }
                    
                    const stars = generatedEnchants.length > 0 ? generateStars(true) : 0;
                    
                    const rollData = {
                        baseRng: baseRng,
                        finalRng: finalRng,
                        rank: rankName,
                        variant: variant.name,
                        enchants: generatedEnchants,
                        stars: stars,
                        timestamp: Date.now(),
                        rollNumber: rollNumber,
                        isSecret: !!secret,
                        secretChance: secretChance,
                        generatedIndex: i
                    };
                    
                    generatedRolls.push(rollData);
                    currentRollGeneratedRolls.push(rollData);
                    
                    pauseRNGThreshold = parseFloat(document.getElementById('pauseRNG').value) || 0;
                    pauseSecretRarityThreshold = parseFloat(document.getElementById('pauseSecretRarity').value) || 0;
                    pauseEnchantRarityThreshold = parseFloat(document.getElementById('pauseEnchantRarity').value) || 0;
                    
                    if (pauseEnchantRarityThreshold > 0 && generatedEnchants.length > 0) {
                        generatedEnchants.forEach(enchant => {
                            const enchantType = ENCHANT_TYPES.find(e => e.name === enchant.name);
                            if (enchantType) {
                                const rarity = 1 / enchantType.chance;
                                if (rarity >= pauseEnchantRarityThreshold) {
                                    foundEnchantToPause = true;
                                    pausedSlotIndex = i;
                                }
                            }
                        });
                    }
                    
                    if (isAutorolling && pauseRNGThreshold > 0 && finalRng >= pauseRNGThreshold && finalRng > 0) {
                        foundRNGToPause = true;
                        pausedSlotIndex = i;
                    }
                    
                    if (isAutorolling && pauseSecretRarityThreshold > 0 && secret) {
                        const secretObj = SECRETS.find(s => s.name === secret);
                        if (secretObj && secretObj.chance >= pauseSecretRarityThreshold) {
                            foundSecretToPause = true;
                            pausedSlotIndex = i;
                        }
                    }
                }
                
                pendingRolls = new Array(totalDisplaySlots).fill(null);
                for (let i = 0; i < totalDisplaySlots; i++) {
                    const rollData = generatedRolls[i];
                    
                    if (rollData) {
                        pendingRolls[i] = rollData;
                        displaySlot(i, rollData.baseRng, rollData.finalRng, rollData.rank, 
                                  rollData.variant, rollData.enchants, rollData.stars, 
                                  rollData.isSecret, rollData.secretChance);
                    }
                }
                
                // Center on the slot that triggered the pause
                if (pausedSlotIndex !== -1) {
                    const viewport = document.getElementById('rollerViewport');
                    const pausedSlot = document.getElementById(`slot-${pausedSlotIndex}`);
                    if (viewport && pausedSlot) {
                        const slotLeft = pausedSlot.offsetLeft;
                        const viewportWidth = viewport.offsetWidth;
                        const slotWidth = pausedSlot.offsetWidth;
                        viewport.scrollLeft = slotLeft - (viewportWidth / 2) + (slotWidth / 2);
                    }
                    
                    // Pause autoroll if needed and show toast
                    if (isAutorolling && (foundRNGToPause || foundSecretToPause || foundEnchantToPause)) {
                        let toastTitle = 'Autoroll Paused';
                        let toastMessage = '';
                        
                        if (foundRNGToPause) {
                            const roll = generatedRolls[pausedSlotIndex];
                            toastMessage = `RNG ‚â• ${formatNumber(pauseRNGThreshold)}: ${formatNumber(roll.finalRng)}`;
                        } else if (foundSecretToPause) {
                            const roll = generatedRolls[pausedSlotIndex];
                            toastMessage = `Secret rarity ‚â• ${formatNumber(pauseSecretRarityThreshold)}: ${roll.rank}`;
                        } else if (foundEnchantToPause) {
                            const roll = generatedRolls[pausedSlotIndex];
                            toastMessage = `Enchant rarity ‚â• ${formatNumber(pauseEnchantRarityThreshold)}: ${roll.enchants.map(e => e.name).join(', ')}`;
                        }
                        
                        showToast(toastTitle, toastMessage, 5000);
                        toggleAutoroll();
                    }
                } else {
                    // Auto-scroll to the middle if no specific pause
                    const viewport = document.getElementById('rollerViewport');
                    if (viewport && totalDisplaySlots > 0) {
                        const middleIndex = Math.floor(totalDisplaySlots / 2);
                        const middleSlot = document.getElementById(`slot-${middleIndex}`);
                        if (middleSlot) {
                            const slotLeft = middleSlot.offsetLeft;
                            const viewportWidth = viewport.offsetWidth;
                            const slotWidth = middleSlot.offsetWidth;
                            viewport.scrollLeft = slotLeft - (viewportWidth / 2) + (slotWidth / 2);
                        }
                    }
                }
                
                updateBottomStats();
                updateUI();
                updateIndex();
                saveGame();
                isRolling = false;
                
                if (cooldownThreshold > 0 && maxRoll >= cooldownThreshold) {
                    let countdown = cooldownTime;
                    const rollBtn = document.getElementById('rollBtn');
                    rollBtn.textContent = `cooldown: ${countdown.toFixed(1)}s`;
                    
                    const interval = setInterval(() => {
                        countdown -= 0.1;
                        if (countdown <= 0) {
                            clearInterval(interval);
                            rollBtn.textContent = 'roll';
                            rollBtn.disabled = false;
                        } else {
                            rollBtn.textContent = `cooldown: ${countdown.toFixed(1)}s`;
                        }
                    }, 100);
                } else {
                    document.getElementById('rollBtn').disabled = false;
                }
            }, rollSpeed * 1000);
        }

        function buyUpgrade(type) {
            if (type === 'bulk') {
                if (bulkLevel >= 100 || polycoin < bulkCost) return;
                polycoin -= bulkCost;
                bulkLevel++;
                bulkCost *= 100;
                updateSlots();
            } else if (type === 'luck') {
                if (luckLevel >= 100 || polycoin < luckCost) return;
                polycoin -= luckCost;
                luckLevel++;
                luckCost = Math.floor(luckCost * 1.15);
            } else if (type === 'secret') {
                if (secretLevel >= 25 || polycoin < secretCost) return;
                polycoin -= secretCost;
                secretLevel++;
                secretCost = Math.floor(secretCost * 1.3333);
            } else if (type === 'speed') {
                if (speedLevel >= 25 || polycoin < speedCost) return;
                polycoin -= speedCost;
                speedLevel++;
                speedCost = Math.floor(speedCost * 1.15);
            } else if (type === 'inventory') {
                const nextInvCost = calculateInvCost();
                if (invLevel >= 40 || polycoin < nextInvCost) return;
                polycoin -= nextInvCost;
                invLevel++;
            } else if (type === 'enchantLuck') {
                if (enchantLuckLevel >= 15 || polycoin < enchantLuckCost) return;
                polycoin -= enchantLuckCost;
                enchantLuckLevel++;
                enchantLuckCost = Math.floor(enchantLuckCost * 1.175);
            } else if (type === 'variantLuck') {
                if (variantLuckLevel >= 30 || polycoin < variantLuckCost) return;
                polycoin -= variantLuckCost;
                variantLuckLevel++;
                variantLuckCost = Math.floor(variantLuckCost * 1.2);
            } else if (type === 'eternium') {
                if (eterniumLevel >= 4 || polycoin < eterniumCost) return;
                polycoin -= eterniumCost;
                eterniumLevel++;
                eterniumCost *= 1000;
            } else if (type === 'ultimatiplier') {
                if (ultimatiplierLevel >= 100 || polycoin < ultimatiplierCost) return;
                polycoin -= ultimatiplierCost;
                ultimatiplierLevel++;
                ultimatiplierCost = Math.floor(ultimatiplierCost * 1.2);
            }
            updateBottomStats();
            updateUI();
            saveGame();
        }

        function buyMinSpeedUpgrade() {
            if (minSpeedUpgrades >= 4 || tickets < 5) return;
            tickets -= 5;
            minSpeedUpgrades++;
            updateBottomStats();
            updateUI();
            saveGame();
        }

        function buyTicketProduction() {
            if (ticketProdLevel >= 2 || tickets < ticketProdCost) return;
            tickets -= ticketProdCost;
            ticketProdLevel++;
            ticketProdCost *= 10;
            startTicketTimer();
            updateBottomStats();
            updateUI();
            saveGame();
        }

        function buySpinner() {
            if (spinnerUnlocked || tickets < 10) return;
            tickets -= 10;
            spinnerUnlocked = true;
            document.getElementById('spinnerSection').style.display = 'block';
            document.getElementById('spinBtn').disabled = tickets < 5;
            createSpinnerWheel();
            updateBottomStats();
            updateUI();
            saveGame();
        }

        function createSpinnerWheel() {
            const wheel = document.getElementById('spinnerWheel');
            wheel.innerHTML = '<div class="wheel-pointer"></div>';
            
            const totalWeight = SPINNER_REWARDS.reduce((sum, reward) => sum + reward.weight, 0);
            let startAngle = 0;
            
            SPINNER_REWARDS.forEach((reward, index) => {
                const segmentAngle = (reward.weight / totalWeight) * 360;
                const segment = document.createElement('div');
                segment.className = 'wheel-segment';
                segment.style.backgroundColor = reward.color;
                segment.style.transform = `rotate(${startAngle}deg)`;
                segment.style.clipPath = `polygon(50% 50%, 50% 0%, 100% 0%, 100% 100%, 50% 50%)`;
                
                const textDiv = document.createElement('div');
                textDiv.textContent = reward.name;
                textDiv.style.transform = `rotate(${segmentAngle/2}deg) translate(60px) rotate(-${segmentAngle/2}deg)`;
                textDiv.style.fontSize = '11px';
                textDiv.style.fontWeight = 'bold';
                textDiv.style.color = 'black';
                textDiv.style.textAlign = 'center';
                textDiv.style.width = '50px';
                textDiv.style.height = '20px';
                textDiv.style.lineHeight = '20px';
                textDiv.style.overflow = 'hidden';
                textDiv.style.whiteSpace = 'nowrap';
                
                segment.appendChild(textDiv);
                wheel.appendChild(segment);
                startAngle += segmentAngle;
            });
        }

        function spinWheel() {
            if (!spinnerUnlocked || tickets < 5) return;
            
            tickets -= 5;
            const spinBtn = document.getElementById('spinBtn');
            const resultDiv = document.getElementById('spinResult');
            
            spinBtn.disabled = true;
            resultDiv.textContent = 'Spinning...';
            
            const wheel = document.getElementById('spinnerWheel');
            const spinDuration = 3000 + Math.random() * 1000;
            const spins = 5 + Math.random() * 3;
            const totalRotation = 360 * spins + Math.random() * 360;
            
            wheel.style.transition = `transform ${spinDuration}ms cubic-bezier(0.34, 1.56, 0.64, 1)`;
            wheel.style.transform = `rotate(${totalRotation}deg)`;
            
            setTimeout(() => {
                const totalWeight = SPINNER_REWARDS.reduce((sum, reward) => sum + reward.weight, 0);
                
                const normalizedRotation = totalRotation % 360;
                
                let cumulativeAngle = 0;
                let winningIndex = 0;
                let segmentAngles = [];
                
                SPINNER_REWARDS.forEach(reward => {
                    segmentAngles.push((reward.weight / totalWeight) * 360);
                });
                
                const pointerAngle = (360 - normalizedRotation + 360) % 360;
                
                for (let i = 0; i < segmentAngles.length; i++) {
                    cumulativeAngle += segmentAngles[i];
                    if (pointerAngle <= cumulativeAngle) {
                        winningIndex = i;
                        break;
                    }
                }
                
                const reward = SPINNER_REWARDS[winningIndex];
                
                let enchants = [];
                if (reward.name === 'combo') {
                    enchants = [
                        { name: 'luck ii', type: 'luck', value: 10, color: '#00ff00', priority: 2 },
                        { name: 'speed ii', type: 'speed', value: 0.5, color: '#1e90ff', priority: 2 },
                        { name: 'insight i', type: 'secret', value: 5, color: '#9370db', priority: 1 }
                    ];
                } else {
                    enchants = [{
                        name: reward.name,
                        type: reward.type,
                        value: reward.value,
                        color: reward.color,
                        priority: reward.priority || 1
                    }];
                }
                
                const stars = generateStars(true);
                const orb = {
                    id: Date.now() + Math.random(),
                    enchants: enchants,
                    sourceRNG: 0,
                    variant: 'spinner',
                    stars: stars,
                    locked: false
                };
                
                enchantOrbs.push(orb);
                updateEnchantInventory();
                updateMergeSelects();
                updateBottomStats();
                updateUI();
                saveGame();
                
                resultDiv.innerHTML = `Won: <strong style="color: ${reward.color}">${reward.name}</strong>${stars > 0 ? ' with ' + '‚≠ê'.repeat(stars) + ' stars' : ''}!`;
                spinBtn.disabled = tickets < 5;
                
                setTimeout(() => {
                    wheel.style.transition = 'none';
                    wheel.style.transform = 'rotate(0deg)';
                    setTimeout(() => {
                        wheel.style.transition = `transform ${spinDuration}ms cubic-bezier(0.34, 1.56, 0.64, 1)`;
                    }, 50);
                }, 1000);
            }, spinDuration);
        }

        function updateInventory() {
            const list = document.getElementById('inventoryList');
            const maxSlots = 10 + invLevel;
            
            document.getElementById('invCount').textContent = formatNumber(inventory.length);
            document.getElementById('invMax').textContent = formatNumber(maxSlots);
            
            if (inventory.length === 0) {
                list.innerHTML = '<div style="text-align: center; color: #999;">no accepted rolls yet!</div>';
                return;
            }
            
            list.innerHTML = inventory.map((item, index) => {
                const color = getRNGColor(item.finalRng, item.rank);
                let style = `color: ${color};`;
                if (color.includes('gradient')) {
                    style = `background: ${color}; -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;`;
                }
                
                const enchantsHTML = item.enchants && item.enchants.length > 0 
                    ? `<div style="font-size: 12px; color: #666;">+${item.enchants.length} enchants</div>`
                    : '';
                
                const starsHTML = item.stars && item.stars > 0 
                    ? `<div style="font-size: 11px; color: gold;">${'‚≠ê'.repeat(item.stars)}</div>`
                    : '';
                
                const tier = getInventoryTier(item.finalRng);
                const tierClass = `tier-${tier.stars}`;
                const rankFontClass = getRankFont(item.rank);
                
                // Apply rank color to rank name
                const rankColor = getRNGColor(item.finalRng, item.rank);
                let rankStyle = `color: ${rankColor};`;
                if (rankColor.includes('gradient')) {
                    rankStyle = `background: ${rankColor}; -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;`;
                }
                
                return `
                    <div class="inventory-item ${tierClass} ${rankFontClass} ${item.rank === 'solar' ? 'solar-rank' : item.rank === 'poly¬≤' ? 'poly-squared-rank' : item.rank === 'Completionist' ? 'completionist-rank' : item.rank === 'NULL' ? 'null-rank' : item.rank === 'ahur yp' ? 'ahur-yp-rank' : ''}">
                        <div class="tier-name">${tier.name}</div>
                        <div class="tier-stars">${tier.stars}‚òÖ</div>
                        <div>
                            <span class="inventory-rng" style="${style}">${formatNumber(item.finalRng)}</span>
                            <div class="inventory-details"><span style="${rankStyle}">${item.rank}</span> - ${item.variant} (x${formatNumber(Math.round(item.finalRng/item.baseRng))})</div>
                            ${starsHTML}
                            ${enchantsHTML}
                        </div>
                        <button class="decline-btn" onclick="deleteInventoryItem(${index})" style="padding: 5px 15px; font-size: 12px;">delete</button>
                    </div>
                `;
            }).join('');
        }

        function getEnchantDescription(enchant, stars = 0) {
            const starBonus = stars > 0 ? ` (${1 + stars * 0.2}x)` : '';
            
            if (enchant.type === 'luck') {
                const val = applyStarBonus(enchant.value, stars);
                return `+${val.toFixed(1)} luck${starBonus}`;
            }
            if (enchant.type === 'speed') {
                const val = applyStarBonus(enchant.value, stars);
                return `+${val.toFixed(2)}s speed${starBonus}`;
            }
            if (enchant.type === 'secret') {
                const val = applyStarBonus(enchant.value, stars);
                return `+${val.toFixed(1)} secret${starBonus}`;
            }
            if (enchant.type === 'variant') {
                const val = applyStarBonus(enchant.value, stars);
                return `+${val.toFixed(1)} variant luck${starBonus}`;
            }
            if (enchant.type === 'addition') return `+${enchant.value} bulk roll`;
            if (enchant.type === 'avarice') {
                const bulk = applyStarBonus(enchant.bulk, stars);
                const luck = applyStarBonus(enchant.luck, stars);
                const speed = applyStarBonus(enchant.speed, stars);
                const variant = applyStarBonus(enchant.variant, stars);
                const secret = applyStarBonus(enchant.secret, stars);
                return `+${bulk.toFixed(0)} bulk, ${luck.toFixed(1)} luck, ${speed.toFixed(1)}s speed, ${variant.toFixed(1)} variant, ${secret.toFixed(1)} secret${starBonus}`;
            }
            if (enchant.type === 'requiem') {
                if (enchant.value === 1) {
                    const luck = applyStarBonus(5, stars);
                    const speed = applyStarBonus(0.25, stars);
                    const secret = applyStarBonus(5, stars);
                    const variant = applyStarBonus(0.5, stars);
                    return `+${luck.toFixed(1)} luck, +${speed.toFixed(2)}s speed, +${secret.toFixed(1)} secret, +${variant.toFixed(1)} variant, +1 bulk${starBonus}`;
                }
                if (enchant.value === 2) {
                    const luck = applyStarBonus(10, stars);
                    const speed = applyStarBonus(0.5, stars);
                    const secret = applyStarBonus(25, stars);
                    const variant = applyStarBonus(2.5, stars);
                    return `+${luck.toFixed(1)} luck, +${speed.toFixed(2)}s speed, +${secret.toFixed(1)} secret, +${variant.toFixed(1)} variant, +2 bulk${starBonus}`;
                }
                if (enchant.value === 3) {
                    const luck = applyStarBonus(50, stars);
                    const speed = applyStarBonus(75, stars);
                    const secret = applyStarBonus(125, stars);
                    const variant = applyStarBonus(20, stars);
                    return `+${luck.toFixed(1)} luck, +${speed.toFixed(2)}s speed, +${secret.toFixed(1)} secret, +${variant.toFixed(1)} variant, +5 bulk${starBonus}`;
                }
            }
            if (enchant.type === 'greed') {
                const luck = applyStarBonus(20, stars);
                const speed = applyStarBonus(0.7, stars);
                return `+2 bulk roll, -${luck.toFixed(1)} luck, -${speed.toFixed(2)}s speed${starBonus}`;
            }
            if (enchant.type === 'patience') {
                const luck = applyStarBonus(100, stars);
                const speed = applyStarBonus(25, stars);
                const variant = applyStarBonus(5, stars);
                return `+3 bulk roll, +${luck.toFixed(1)} luck, -${speed.toFixed(2)}s speed, +${variant.toFixed(1)} variant${starBonus}`;
            }
            if (enchant.type === 'alpha') {
                const luck = applyStarBonus(0.25, stars);
                const speed = applyStarBonus(0.05, stars);
                const secret = applyStarBonus(0.5, stars);
                const variant = applyStarBonus(0.125, stars);
                return `+${luck.toFixed(2)} luck, -${speed.toFixed(2)}s speed, +${secret.toFixed(2)} secret, +${variant.toFixed(3)} variant${starBonus}`;
            }
            if (enchant.type === 'delta') {
                const luck = applyStarBonus(2.5, stars);
                const speed = applyStarBonus(0.5, stars);
                const secret = applyStarBonus(5, stars);
                const variant = applyStarBonus(1.25, stars);
                return `+${luck.toFixed(2)} luck, -${speed.toFixed(2)}s speed, +${secret.toFixed(2)} secret, +${variant.toFixed(3)} variant (alpha x10)${starBonus}`;
            }
            if (enchant.type === 'weird') {
                const val = applyStarBonus(enchant.value, stars);
                return `+${val.toFixed(2)} enchant luck${starBonus}`;
            }
            if (enchant.type === 'overtime') {
                const luck = applyStarBonus(enchant.currentLuck, stars);
                const speed = applyStarBonus(enchant.currentSpeed, stars);
                const variant = applyStarBonus(enchant.currentVariant, stars);
                const secret = applyStarBonus(enchant.currentSecret, stars);
                const rolls = (enchant.rollsWithOvertime || 0);
                return `+${luck.toFixed(3)} luck, +${speed.toFixed(3)}s speed, +${variant.toFixed(3)} variant, +${secret.toFixed(3)} secret (${rolls} rolls)${starBonus}`;
            }
            if (enchant.type === 'blessing') {
                return `1/333,333 chance for poly¬≤ (RNG: -2,932,932)${starBonus}`;
            }
            if (enchant.type === 'obliteration') {
                const luck = applyStarBonus(500, stars);
                const secret = applyStarBonus(20, stars);
                const speed = applyStarBonus(2, stars);
                const variant = applyStarBonus(17.5, stars);
                return `-1000 bulk (sets to 1), +${luck.toFixed(1)} luck, +${secret.toFixed(1)} secret, +${speed.toFixed(2)}s speed, +${variant.toFixed(1)} variant${starBonus}`;
            }
            return '';
        }

        function updateCooldownSettings() {
            cooldownThreshold = parseFloat(document.getElementById('cooldownThreshold').value) || 0;
            cooldownTime = parseFloat(document.getElementById('cooldownTime').value) || 3;
            saveGame();
        }

        function getStarDisplay(stars) {
            if (!stars || stars === 0) return '';
            return '‚≠ê'.repeat(stars);
        }

        function updateEnchantInventory() {
            const equippedList = document.getElementById('equippedEnchant');
            const inventoryList = document.getElementById('enchantInventoryList');
            document.getElementById('enchantCount').textContent = formatNumber(enchantOrbs.length);
            document.getElementById('enchants').textContent = formatNumber(enchantOrbs.length);
            
            if (!equippedOrb) {
                equippedList.innerHTML = '<div style="text-align: center; color: #999;">no enchant orb equipped!</div>';
            } else {
                const starDisplay = getStarDisplay(equippedOrb.stars);
                const enchantsList = equippedOrb.enchants.map(e => 
                    `<span style="color: ${e.color}; font-weight: bold;">${e.name}</span>`
                ).join(', ');
                
                const effectsList = equippedOrb.enchants.map(e => getEnchantDescription(e, equippedOrb.stars)).join(' | ');
                
                equippedList.innerHTML = `
                    <div class="inventory-item ${equippedOrb.locked ? 'locked-enchant' : ''}">
                        <div>
                            ${starDisplay ? `<div class="star-display">${starDisplay}</div>` : ''}
                            <div style="margin-bottom: 5px;">${enchantsList}</div>
                            <div style="font-size: 12px; color: #666;">${effectsList}</div>
                            <div style="font-size: 11px; color: #999;">from: ${equippedOrb.sourceRNG ? formatNumber(equippedOrb.sourceRNG) : '?'} ${equippedOrb.variant || ''}</div>
                        </div>
                        <button class="unequip-btn" onclick="unequipEnchantOrb()" style="padding: 5px 15px; font-size: 12px;">unequip</button>
                    </div>
                `;
            }
            
            if (enchantOrbs.length === 0) {
                inventoryList.innerHTML = '<div style="text-align: center; color: #999;">no enchant orbs yet!</div>';
                return;
            }
            
            inventoryList.innerHTML = enchantOrbs.map((orb, index) => {
                const starDisplay = getStarDisplay(orb.stars);
                const enchantsList = orb.enchants.map(e => 
                    `<span style="color: ${e.color}; font-weight: bold;">${e.name}</span>`
                ).join(', ');
                
                const effectsList = orb.enchants.map(e => getEnchantDescription(e, orb.stars)).join(' | ');
                
                const isEquipped = equippedOrb && equippedOrb.id === orb.id;
                const canUnmerge = orb.enchants.length > 1;
                
                return `
                    <div class="inventory-item ${orb.locked ? 'locked-enchant' : ''}">
                        <div>
                            ${starDisplay ? `<div class="star-display">${starDisplay}</div>` : ''}
                            <div style="margin-bottom: 5px;">${enchantsList}</div>
                            <div style="font-size: 12px; color: #666;">${effectsList}</div>
                            <div style="font-size: 11px; color: #999;">from: ${orb.sourceRNG ? formatNumber(orb.sourceRNG) : '?'} ${orb.variant || ''}</div>
                        </div>
                        <div>
                            ${isEquipped ? 
                                '<span style="color: #90ee90; font-size: 12px;">equipped</span>' : 
                                `<button class="equip-btn" onclick="equipEnchantOrb(${index})" style="padding: 5px 10px; font-size: 11px;">equip</button>`
                            }
                            <button class="decline-btn" onclick="deleteEnchantOrb(${index})" style="padding: 5px 10px; font-size: 11px;">delete</button>
                            ${canUnmerge ? `<button class="unmerge-btn" onclick="document.getElementById('mergeOrb1').value=${index};updateMergePreview();" style="padding: 5px 10px; font-size: 11px;">select to unmerge</button>` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updateMergeSelects() {
            const select1 = document.getElementById('mergeOrb1');
            const select2 = document.getElementById('mergeOrb2');
            const unmergeBtn = document.getElementById('unmergeBtn');
            
            select1.innerHTML = '<option value="-1">Select first orb</option>';
            select2.innerHTML = '<option value="-1">Select second orb</option>';
            
            enchantOrbs.forEach((orb, index) => {
                if (!orb.locked) {
                    const optionText = `Orb ${index + 1}: ${orb.enchants.map(e => abbreviateEnchant(e.name)).join(', ')} ${orb.stars > 0 ? '‚≠ê'.repeat(orb.stars) : ''}`;
                    select1.innerHTML += `<option value="${index}">${optionText}</option>`;
                    select2.innerHTML += `<option value="${index}">${optionText}</option>`;
                }
            });
            
            updateMergePreview();
        }

        function updateMergePreview() {
            const orb1Index = parseInt(document.getElementById('mergeOrb1').value);
            const orb2Index = parseInt(document.getElementById('mergeOrb2').value);
            const mergeBtn = document.getElementById('mergeBtn');
            const unmergeBtn = document.getElementById('unmergeBtn');
            const preview = document.getElementById('mergePreview');
            
            // Update unmerge button state
            if (orb1Index !== -1) {
                const selectedOrb = enchantOrbs[orb1Index];
                if (selectedOrb && selectedOrb.enchants.length > 1) {
                    unmergeBtn.disabled = rollCoins < 100000;
                } else {
                    unmergeBtn.disabled = true;
                }
            } else {
                unmergeBtn.disabled = true;
            }
            
            if (orb1Index === -1 || orb2Index === -1 || orb1Index === orb2Index) {
                mergeBtn.disabled = true;
                if (orb1Index !== -1 && orb2Index !== -1 && orb1Index === orb2Index) {
                    preview.textContent = 'Select two different orbs to merge.';
                } else {
                    preview.textContent = 'Select two orbs to merge.';
                }
                return;
            }
            
            const orb1 = enchantOrbs[orb1Index];
            const orb2 = enchantOrbs[orb2Index];
            
            if (orb1.locked || orb2.locked) {
                mergeBtn.disabled = true;
                preview.textContent = 'Cannot merge locked orbs.';
                return;
            }
            
            if (rollCoins < 500) {
                mergeBtn.disabled = true;
                preview.textContent = `Need 500 roll coins to merge (you have ${formatNumber(rollCoins)}).`;
                return;
            }
            
            mergeBtn.disabled = false;
            
            const alphaCount1 = orb1.enchants.filter(e => e.name === 'alpha').length;
            const alphaCount2 = orb2.enchants.filter(e => e.name === 'alpha').length;
            const deltaCount1 = orb1.enchants.filter(e => e.name === 'delta').length;
            const deltaCount2 = orb2.enchants.filter(e => e.name === 'delta').length;
            
            const combinedEnchants = [...orb1.enchants, ...orb2.enchants];
            
            const alphaEnchants = combinedEnchants.filter(e => e.name === 'alpha');
            const deltaEnchants = combinedEnchants.filter(e => e.name === 'delta');
            const otherEnchants = combinedEnchants.filter(e => e.name !== 'alpha' && e.name !== 'delta');
            
            const finalEnchants = [];
            const overrideExceptions = ['requiem i', 'requiem ii', 'genesis', 'blitz', 'omnipotence', 'endless', 'unusual', 'unusuality', 'overtime', 'polys blessing', 'obliteration', 'avarice'];
            
            if (alphaEnchants.length > 0 || deltaEnchants.length > 0) {
                finalEnchants.push(...alphaEnchants, ...deltaEnchants);
                
                otherEnchants.forEach(enchant => {
                    if (!shouldOverrideEnchant(enchant.name) || overrideExceptions.includes(enchant.name.toLowerCase())) {
                        finalEnchants.push(enchant);
                    }
                });
            } else {
                finalEnchants.push(...combinedEnchants);
            }
            
            const avgStars = Math.ceil((orb1.stars + orb2.stars) / 2);
            
            const shouldBeLocked = !((alphaCount1 > 0 && alphaCount2 > 0) || (deltaCount1 > 0 && deltaCount2 > 0));
            
            preview.innerHTML = `
                <strong>Merge Preview:</strong><br>
                Combined enchants: ${finalEnchants.map(e => `<span style="color: ${e.color}">${e.name}</span>`).join(', ')}<br>
                Stars: ${avgStars > 0 ? '‚≠ê'.repeat(avgStars) : 'None'}<br>
                Original orbs will be deleted${shouldBeLocked ? ', new orb will be locked.' : '.'}
            `;
        }

        function mergeEnchants() {
            const orb1Index = parseInt(document.getElementById('mergeOrb1').value);
            const orb2Index = parseInt(document.getElementById('mergeOrb2').value);
            
            if (orb1Index === -1 || orb2Index === -1 || orb1Index === orb2Index) return;
            if (rollCoins < 500) return;
            
            const orb1 = enchantOrbs[orb1Index];
            const orb2 = enchantOrbs[orb2Index];
            
            if (orb1.locked || orb2.locked) return;
            
            rollCoins -= 500;
            
            const alphaCount1 = orb1.enchants.filter(e => e.name === 'alpha').length;
            const alphaCount2 = orb2.enchants.filter(e => e.name === 'alpha').length;
            const deltaCount1 = orb1.enchants.filter(e => e.name === 'delta').length;
            const deltaCount2 = orb2.enchants.filter(e => e.name === 'delta').length;
            
            const combinedEnchants = [...orb1.enchants, ...orb2.enchants];
            
            const alphaEnchants = combinedEnchants.filter(e => e.name === 'alpha');
            const deltaEnchants = combinedEnchants.filter(e => e.name === 'delta');
            const otherEnchants = combinedEnchants.filter(e => e.name !== 'alpha' && e.name !== 'delta');
            
            const finalEnchants = [];
            const overrideExceptions = ['requiem i', 'requiem ii', 'genesis', 'blitz', 'omnipotence', 'endless', 'unusual', 'unusuality', 'overtime', 'polys blessing', 'obliteration', 'avarice'];
            
            if (alphaEnchants.length > 0 || deltaEnchants.length > 0) {
                finalEnchants.push(...alphaEnchants, ...deltaEnchants);
                
                otherEnchants.forEach(enchant => {
                    if (!shouldOverrideEnchant(enchant.name) || overrideExceptions.includes(enchant.name.toLowerCase())) {
                        if (enchant.type === 'overtime') {
                            const existingOvertime = finalEnchants.find(e => e.type === 'overtime');
                            if (existingOvertime) {
                                existingOvertime.currentLuck = (existingOvertime.currentLuck + enchant.currentLuck) / 2;
                                existingOvertime.currentSpeed = (existingOvertime.currentSpeed + enchant.currentSpeed) / 2;
                                existingOvertime.currentVariant = (existingOvertime.currentVariant + enchant.currentVariant) / 2;
                                existingOvertime.currentSecret = (existingOvertime.currentSecret + enchant.currentSecret) / 2;
                                existingOvertime.rollsWithOvertime = Math.max(existingOvertime.rollsWithOvertime || 0, enchant.rollsWithOvertime || 0);
                            } else {
                                finalEnchants.push(enchant);
                            }
                        } else {
                            finalEnchants.push(enchant);
                        }
                    }
                });
            } else {
                finalEnchants.push(...combinedEnchants);
            }
            
            const avgStars = Math.ceil((orb1.stars + orb2.stars) / 2);
            
            const shouldBeLocked = !((alphaCount1 > 0 && alphaCount2 > 0) || (deltaCount1 > 0 && deltaCount2 > 0));
            
            const mergedOrb = {
                id: Date.now() + Math.random(),
                enchants: finalEnchants,
                sourceRNG: Math.max(orb1.sourceRNG || 0, orb2.sourceRNG || 0),
                variant: orb1.sourceRNG >= orb2.sourceRNG ? orb1.variant : orb2.variant,
                stars: avgStars,
                locked: shouldBeLocked,
                rollsWithOvertime: Math.max(orb1.rollsWithOvertime || 0, orb2.rollsWithOvertime || 0)
            };
            
            const higherIndex = Math.max(orb1Index, orb2Index);
            const lowerIndex = Math.min(orb1Index, orb2Index);
            
            enchantOrbs.splice(higherIndex, 1);
            enchantOrbs.splice(lowerIndex, 1);
            
            enchantOrbs.push(mergedOrb);
            
            updateEnchantInventory();
            updateMergeSelects();
            updateBottomStats();
            updateUI();
            saveGame();
            
            alert(`Enchants merged successfully! Original orbs deleted${shouldBeLocked ? ', new orb is locked' : ''}.`);
        }

        function updateIndex() {
            const variantsHTML = VARIANTS.map(v => {
                const isDiscovered = discovered.variants.has(v.name);
                const icon = isDiscovered ? '‚úì' : '‚úó';
                const style = isDiscovered ? 'color: #90ee90;' : 'color: #ff6666;';
                return `<div class="index-item"><span style="${style}">${icon}</span> ${v.name}: ${formatNumber(v.multipliesRNG)}x (1/${formatNumber(v.chance)})</div>`;
            }).join('');
            document.getElementById('variantsIndexItems').innerHTML = variantsHTML;
            
            const normalRanksHTML = RANKS.map(r => {
                const isDiscovered = discovered.ranks.has(r.name) && !SECRETS.some(s => s.name === r.name);
                const icon = isDiscovered ? '‚úì' : '‚úó';
                const style = isDiscovered ? 'color: #90ee90;' : 'color: #ff6666;';
                const maxDisplay = r.max === Infinity ? '‚àû' : formatNumber(r.max);
                const fontClass = getIndexRankFont(r.name);
                const color = getRNGColor(r.min, r.name);
                let rankStyle = `color: ${color};`;
                if (color.includes('gradient')) {
                    rankStyle = `background: ${color}; -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;`;
                }
                return `<div class="index-item ${fontClass}"><span style="${style}">${icon}</span> <span style="${rankStyle}">${r.name}</span>: ${formatNumber(r.min)} - ${maxDisplay}</div>`;
            }).join('');
            document.getElementById('normalRanksIndexItems').innerHTML = normalRanksHTML;
            
            const secretsHTML = SECRETS.map(s => {
                const isDiscovered = discovered.secrets.has(s.name);
                const icon = isDiscovered ? '‚úì' : '‚úó';
                const style = isDiscovered ? 'color: #90ee90;' : 'color: #ff6666;';
                let specialNote = '';
                if (s.name === 'solar') specialNote = ' (replaces eclipse, x100,000)';
                if (s.name === 'Completionist') specialNote = ' (requires all normal ranks, always rollable, RNG: -500)';
                if (s.name === 'poly¬≤') specialNote = '';
                if (s.name === 'NULL') specialNote = '';
                if (s.name === 'ahur yp') specialNote = ' (fixed TRNG: 694200, unaffected by boosts)';
                
                // Apply color to secret name
                let secretColor = '#ff69b4';
                if (s.name === 'solar') secretColor = 'orange';
                if (s.name === 'poly¬≤') secretColor = '#FF00FF';
                if (s.name === 'NULL') {
                    return `<div class="index-item null-rank"><span style="${style}">${icon}</span> <span>${s.name}</span>: 1/${formatNumber(s.chance)}${specialNote}</div>`;
                }
                if (s.name === 'Completionist') {
                    return `<div class="index-item completionist-index"><span style="${style}">${icon}</span> <span>${s.name}</span>: 1/${formatNumber(s.chance)}${specialNote}</div>`;
                }
                if (s.name === 'ahur yp') {
                    return `<div class="index-item rank-almighty"><span style="${style}">${icon}</span> <span style="color: #9b30ff; text-shadow: 0 0 5px #9b30ff;">${s.name}</span>: 1/${formatNumber(s.chance)}${specialNote}</div>`;
                }
                
                return `<div class="index-item"><span style="${style}">${icon}</span> <span style="color: ${secretColor}">${s.name}</span>: 1/${formatNumber(s.chance)}${specialNote}</div>`;
            }).join('');
            document.getElementById('secretRanksIndexItems').innerHTML = secretsHTML;
            
            const enchantsHTML = ENCHANT_TYPES.map(enchant => {
                const isDiscovered = discovered.enchants.has(enchant.name);
                const icon = isDiscovered ? '‚úì' : '‚úó';
                const style = isDiscovered ? 'color: #90ee90;' : 'color: #ff6666;';
                let effect = '';
                if (enchant.type === 'luck') effect = `+${enchant.value} luck`;
                if (enchant.type === 'speed') effect = `+${enchant.value}s speed`;
                if (enchant.type === 'secret') effect = `+${enchant.value} secret`;
                if (enchant.type === 'variant') effect = `+${enchant.value} variant luck`;
                if (enchant.type === 'addition') effect = `+${enchant.value} bulk roll`;
                if (enchant.type === 'alpha') effect = `+0.25 luck, -0.05s speed, +0.5 secret, +0.125 variant`;
                if (enchant.type === 'delta') effect = `+2.5 luck, -0.5s speed, +5 secret, +1.25 variant (alpha x10)`;
                if (enchant.type === 'weird') effect = `+${enchant.value} enchant luck`;
                if (enchant.type === 'overtime') effect = `+0.001 luck, +0.001s speed, +0.001 variant, +0.001 secret (grows per roll)`;
                if (enchant.type === 'blessing') effect = `1/333,333 chance for poly¬≤ (RNG: -2,932,932)`;
                if (enchant.type === 'obliteration') effect = `-1000 bulk (sets to 1), +500 luck, +20 secret, +2s speed, +17.5 variant`;
                if (enchant.type === 'avarice') effect = `+${enchant.bulk} bulk roll, ${enchant.luck} luck, ${enchant.speed}s speed, ${enchant.variant} variant luck, ${enchant.secret} secret luck`;
                if (enchant.type === 'requiem') {
                    if (enchant.value === 1) effect = '+5 luck, +0.25s speed, +5 secret, +0.5 variant, +1 bulk';
                    else if (enchant.value === 2) effect = '+10 luck, +0.5s speed, +25 secret, +2.5 variant, +2 bulk';
                    else if (enchant.value === 3) effect = '+50 luck, +75s speed, +125 secret, +20 variant, +5 bulk';
                }
                if (enchant.type === 'greed') effect = '+2 bulk roll, -20 luck, -0.7s speed';
                if (enchant.type === 'patience') effect = '+3 bulk roll, +100 luck, -25s speed, +5 variant';
                const chanceDisplay = Math.round(1/enchant.chance);
                return `<div class="index-item"><span style="${style}">${icon}</span> <span style="color: ${enchant.color}">${enchant.name}</span>: ${effect} (1/${formatNumber(chanceDisplay)})</div>`;
            }).join('');
            document.getElementById('enchantsIndexItems').innerHTML = enchantsHTML;
        }

        function calculateInvCost() {
            if (invLevel === 0) return 0;
            return Math.floor(20 * Math.log(invLevel) / Math.log(3));
        }

        function updateBottomStats() {
            const statsGrid = document.getElementById('bottomStatsGrid');
            
            // FIXED: Calculate time elapsed safely
            const timeElapsed = Date.now() - gameStartTime;
            const rollsPerMinute = timeElapsed > 0 ? Math.round(totalRolls / (timeElapsed / 60000)) : 0;
            
            const stats = [
                { title: 'Total Polycoin Earned', value: formatNumber(polycoin + inventory.reduce((sum, item) => sum + (item.finalRng > 0 ? Math.floor(Math.pow(item.finalRng, 0.8) * 0.75) : 0), 0)) },
                { title: 'Average Roll RNG', value: formatNumber(inventory.length > 0 ? (inventory.reduce((sum, item) => sum + item.finalRng, 0) / inventory.length) || 0 : 0) },
                { title: 'Rolls per Minute', value: formatNumber(rollsPerMinute) },
                { title: 'Total Enchants Found', value: formatNumber(enchantOrbs.reduce((sum, orb) => sum + orb.enchants.length, 0)) },
                { title: 'Average Enchant Stars', value: formatNumber(enchantOrbs.length > 0 ? (enchantOrbs.reduce((sum, orb) => sum + (orb.stars || 0), 0) / enchantOrbs.length).toFixed(2) : '0.00') },
                { title: 'Secrets Discovered', value: `${discovered.secrets.size}/${SECRETS.length}` },
                { title: 'Variants Discovered', value: `${discovered.variants.size}/${VARIANTS.length}` },
                { title: 'Ranks Discovered', value: `${discovered.ranks.size}/${RANKS.length + SECRETS.length}` },
                { title: 'Enchants Discovered', value: `${discovered.enchants.size}/${ENCHANT_TYPES.length}` },
                { title: 'Highest Inventory Tier', value: inventory.length > 0 ? getInventoryTier(Math.max(...inventory.map(i => i.finalRng))).name : 'None' },
                { title: 'Equipped Enchant Power', value: equippedOrb ? formatNumber(equippedOrb.enchants.reduce((sum, e) => sum + (e.value || e.bulk || 0), 0)) : '0' },
                { title: 'Active Upgrades', value: formatNumber(bulkLevel + luckLevel + secretLevel + speedLevel + invLevel + enchantLuckLevel + variantLuckLevel + eterniumLevel + ultimatiplierLevel) }
            ];
            
            statsGrid.innerHTML = stats.map(stat => `
                <div class="stat-item">
                    <div class="stat-item-title">${stat.title}</div>
                    <div class="stat-item-value">${stat.value}</div>
                </div>
            `).join('');
        }

        function updateUI() {
            document.getElementById('polycoin').textContent = formatNumber(Math.floor(polycoin));
            document.getElementById('best').textContent = formatNumber(bestRoll);
            document.getElementById('rolls').textContent = formatNumber(totalRolls);
            document.getElementById('rollCoins').textContent = formatNumber(rollCoins);
            document.getElementById('tickets').textContent = formatNumber(tickets);
            
            document.getElementById('bulkLevel').textContent = formatNumber(bulkLevel);
            document.getElementById('bulkCost').textContent = formatNumber(bulkCost);
            document.getElementById('bulkBtn').disabled = bulkLevel >= 100 || polycoin < bulkCost;
            
            document.getElementById('luckLevel').textContent = formatNumber(luckLevel);
            document.getElementById('luckAmount').textContent = (luckLevel * 0.5).toFixed(1);
            document.getElementById('luckCost').textContent = formatNumber(luckCost);
            document.getElementById('luckBtn').disabled = luckLevel >= 100 || polycoin < luckCost;
            
            document.getElementById('secretLevel').textContent = formatNumber(secretLevel);
            document.getElementById('secretAmount').textContent = (secretLevel * 0.2).toFixed(1);
            document.getElementById('secretCost').textContent = formatNumber(secretCost);
            document.getElementById('secretBtn').disabled = secretLevel >= 25 || polycoin < secretCost;
            
            const totalSpeedReduction = speedLevel * 0.1 + getTotalEnchantSpeed();
            const minRollSpeed = Math.max(0.05 - (minSpeedUpgrades * 0.01), 0.01);
            document.getElementById('speedLevel').textContent = formatNumber(speedLevel);
            document.getElementById('speedAmount').textContent = Math.max(minRollSpeed, 3 - totalSpeedReduction).toFixed(2);
            document.getElementById('speedCost').textContent = formatNumber(speedCost);
            document.getElementById('speedBtn').disabled = speedLevel >= 25 || polycoin < speedCost;
            
            const nextInvCost = calculateInvCost();
            document.getElementById('invLevel').textContent = formatNumber(10 + invLevel);
            document.getElementById('invCost').textContent = formatNumber(nextInvCost);
            document.getElementById('invBtn').disabled = invLevel >= 40 || polycoin < nextInvCost;
            
            document.getElementById('enchantLuckLevel').textContent = formatNumber(enchantLuckLevel);
            document.getElementById('enchantLuckAmount').textContent = (enchantLuckLevel * 0.05).toFixed(2);
            document.getElementById('enchantLuckCost').textContent = formatNumber(enchantLuckCost);
            document.getElementById('enchantLuckBtn').disabled = enchantLuckLevel >= 15 || polycoin < enchantLuckCost;
            
            document.getElementById('variantLuckLevel').textContent = formatNumber(variantLuckLevel);
            document.getElementById('variantLuckAmount').textContent = (variantLuckLevel * 0.05).toFixed(2);
            document.getElementById('variantLuckCost').textContent = formatNumber(variantLuckCost);
            document.getElementById('variantLuckBtn').disabled = variantLuckLevel >= 30 || polycoin < variantLuckCost;
            
            // NEW UPGRADES UI
            document.getElementById('eterniumLevel').textContent = formatNumber(eterniumLevel);
            document.getElementById('eterniumAmount').textContent = (eterniumLevel * 5).toFixed(0);
            document.getElementById('eterniumCost').textContent = formatNumber(eterniumCost);
            document.getElementById('eterniumBtn').disabled = eterniumLevel >= 4 || polycoin < eterniumCost;
            
            document.getElementById('ultimatiplierLevel').textContent = formatNumber(ultimatiplierLevel);
            document.getElementById('ultimatiplierAmount').textContent = (ultimatiplierLevel * 0.05).toFixed(2);
            document.getElementById('ultimatiplierCost').textContent = formatNumber(ultimatiplierCost);
            document.getElementById('ultimatiplierBtn').disabled = ultimatiplierLevel >= 100 || polycoin < ultimatiplierCost;
            
            document.getElementById('minSpeedLevel').textContent = formatNumber(minSpeedUpgrades);
            document.getElementById('minSpeedCost').textContent = formatNumber(5);
            document.getElementById('minSpeedBtn').disabled = minSpeedUpgrades >= 4 || tickets < 5;
            
            document.getElementById('ticketProdLevel').textContent = formatNumber(ticketProdLevel);
            document.getElementById('ticketProdCost').textContent = formatNumber(ticketProdCost);
            document.getElementById('ticketProdBtn').disabled = ticketProdLevel >= 2 || tickets < ticketProdCost;
            
            document.getElementById('spinnerStatus').textContent = spinnerUnlocked ? 'unlocked' : 'locked';
            document.getElementById('spinnerCost').textContent = formatNumber(10);
            document.getElementById('spinnerBtn').disabled = spinnerUnlocked || tickets < 10;
            
            document.getElementById('spinBtn').disabled = !spinnerUnlocked || tickets < 5;
        }
        
        function startTicketTimer() {
            if (ticketInterval) clearInterval(ticketInterval);
            const ticketsPerMinute = 1 + ticketProdLevel;
            ticketInterval = setInterval(() => {
                tickets += ticketsPerMinute;
                updateBottomStats();
                updateUI();
                saveGame();
            }, 60000);
        }

        function saveGame() {
            try {
                const saveData = {
                    polycoin,
                    bestRoll,
                    totalRolls,
                    rollCoins,
                    tickets,
                    bulkLevel,
                    bulkCost,
                    luckLevel,
                    luckCost,
                    secretLevel,
                    secretCost,
                    speedLevel,
                    speedCost,
                    invLevel,
                    enchantLuckLevel,
                    enchantLuckCost,
                    variantLuckLevel,
                    variantLuckCost,
                    minSpeedUpgrades,
                    ticketProdLevel,
                    ticketProdCost,
                    spinnerUnlocked,
                    cooldownThreshold,
                    cooldownTime,
                    isAutorolling,
                    eterniumLevel,
                    eterniumCost,
                    ultimatiplierLevel,
                    ultimatiplierCost,
                    discovered: {
                        variants: Array.from(discovered.variants),
                        ranks: Array.from(discovered.ranks),
                        secrets: Array.from(discovered.secrets),
                        enchants: Array.from(discovered.enchants)
                    },
                    inventory: inventory.map(item => ({
                        ...item,
                        enchants: item.enchants ? item.enchants.map(e => {
                            if (e.type === 'overtime') {
                                return {
                                    name: e.name,
                                    type: e.type,
                                    baseLuck: e.baseLuck,
                                    baseSpeed: e.baseSpeed,
                                    baseVariant: e.baseVariant,
                                    baseSecret: e.baseSecret,
                                    currentLuck: e.currentLuck,
                                    currentSpeed: e.currentSpeed,
                                    currentVariant: e.currentVariant,
                                    currentSecret: e.currentSecret,
                                    color: e.color,
                                    priority: e.priority
                                };
                            } else if (e.type === 'avarice') {
                                return {
                                    name: e.name,
                                    type: e.type,
                                    bulk: e.bulk,
                                    luck: e.luck,
                                    speed: e.speed,
                                    variant: e.variant,
                                    secret: e.secret,
                                    color: e.color,
                                    priority: e.priority
                                };
                            }
                            return {
                                name: e.name,
                                type: e.type,
                                value: e.value,
                                color: e.color,
                                priority: e.priority
                            };
                        }) : []
                    })),
                    enchantOrbs: enchantOrbs.map(orb => ({
                        id: orb.id,
                        enchants: orb.enchants.map(e => {
                            if (e.type === 'overtime') {
                                return {
                                    name: e.name,
                                    type: e.type,
                                    baseLuck: e.baseLuck,
                                    baseSpeed: e.baseSpeed,
                                    baseVariant: e.baseVariant,
                                    baseSecret: e.baseSecret,
                                    currentLuck: e.currentLuck,
                                    currentSpeed: e.currentSpeed,
                                    currentVariant: e.currentVariant,
                                    currentSecret: e.currentSecret,
                                    color: e.color,
                                    priority: e.priority
                                };
                            } else if (e.type === 'avarice') {
                                return {
                                    name: e.name,
                                    type: e.type,
                                    bulk: e.bulk,
                                    luck: e.luck,
                                    speed: e.speed,
                                    variant: e.variant,
                                    secret: e.secret,
                                    color: e.color,
                                    priority: e.priority
                                };
                            }
                            return {
                                name: e.name,
                                type: e.type,
                                value: e.value,
                                color: e.color,
                                priority: e.priority
                            };
                        }),
                        sourceRNG: orb.sourceRNG,
                        variant: orb.variant,
                        stars: orb.stars || 0,
                        locked: orb.locked || false,
                        rollsWithOvertime: orb.rollsWithOvertime || 0
                    })),
                    equippedOrb: equippedOrb ? {
                        id: equippedOrb.id,
                        enchants: equippedOrb.enchants.map(e => {
                            if (e.type === 'overtime') {
                                return {
                                    name: e.name,
                                    type: e.type,
                                    baseLuck: e.baseLuck,
                                    baseSpeed: e.baseSpeed,
                                    baseVariant: e.baseVariant,
                                    baseSecret: e.baseSecret,
                                    currentLuck: e.currentLuck,
                                    currentSpeed: e.currentSpeed,
                                    currentVariant: e.currentVariant,
                                    currentSecret: e.currentSecret,
                                    color: e.color,
                                    priority: e.priority
                                };
                            } else if (e.type === 'avarice') {
                                return {
                                    name: e.name,
                                    type: e.type,
                                    bulk: e.bulk,
                                    luck: e.luck,
                                    speed: e.speed,
                                    variant: e.variant,
                                    secret: e.secret,
                                    color: e.color,
                                    priority: e.priority
                                };
                            }
                            return {
                                name: e.name,
                                type: e.type,
                                value: e.value,
                                color: e.color,
                                priority: e.priority
                            };
                        }),
                        sourceRNG: equippedOrb.sourceRNG,
                        variant: equippedOrb.variant,
                        stars: equippedOrb.stars || 0,
                        locked: equippedOrb.locked || false,
                        rollsWithOvertime: equippedOrb.rollsWithOvertime || 0
                    } : null,
                    toastNotificationsEnabled,
                    gameStartTime: gameStartTime || Date.now()
                };
                localStorage.setItem('polys-rng-savev5', JSON.stringify(saveData));
            } catch (error) {
                console.error('failed to save game:', error);
            }
        }

        function loadGame() {
            try {
                const result = localStorage.getItem('polys-rng-savev5');
                if (result) {
                    const saveData = JSON.parse(result);
                    
                    polycoin = saveData.polycoin || 0;
                    bestRoll = saveData.bestRoll || 0;
                    totalRolls = saveData.totalRolls || 0;
                    rollCoins = saveData.rollCoins || 0;
                    tickets = saveData.tickets || 0;
                    bulkLevel = saveData.bulkLevel || 1;
                    bulkCost = saveData.bulkCost || 100;
                    luckLevel = saveData.luckLevel || 0;
                    luckCost = saveData.luckCost || 10;
                    secretLevel = saveData.secretLevel || 0;
                    secretCost = saveData.secretCost || 50;
                    speedLevel = saveData.speedLevel || 0;
                    speedCost = saveData.speedCost || 50;
                    invLevel = saveData.invLevel || 0;
                    enchantLuckLevel = saveData.enchantLuckLevel || 0;
                    enchantLuckCost = saveData.enchantLuckCost || 30;
                    variantLuckLevel = saveData.variantLuckLevel || 0;
                    variantLuckCost = saveData.variantLuckCost || 50;
                    minSpeedUpgrades = saveData.minSpeedUpgrades || 0;
                    ticketProdLevel = saveData.ticketProdLevel || 0;
                    ticketProdCost = saveData.ticketProdCost || 50;
                    spinnerUnlocked = saveData.spinnerUnlocked || false;
                    
                    eterniumLevel = saveData.eterniumLevel || 0;
                    eterniumCost = saveData.eterniumCost || 1e12;
                    ultimatiplierLevel = saveData.ultimatiplierLevel || 0;
                    ultimatiplierCost = saveData.ultimatiplierCost || 100;
                    
                    cooldownThreshold = saveData.cooldownThreshold || 0;
                    cooldownTime = saveData.cooldownTime || 3;
                    document.getElementById('cooldownThreshold').value = cooldownThreshold;
                    document.getElementById('cooldownTime').value = cooldownTime;
                    
                    toastNotificationsEnabled = saveData.toastNotificationsEnabled !== undefined ? saveData.toastNotificationsEnabled : true;
                    const toastBtn = document.getElementById('toastToggleBtn');
                    if (toastNotificationsEnabled) {
                        toastBtn.textContent = 'üîî Toasts ON';
                        toastBtn.classList.add('active');
                    } else {
                        toastBtn.textContent = 'üîï Toasts OFF';
                        toastBtn.classList.remove('active');
                    }
                    
                    // FIXED: Set gameStartTime from save or current time
                    gameStartTime = saveData.gameStartTime || Date.now();
                    
                    if (saveData.discovered) {
                        discovered.variants = new Set(saveData.discovered.variants || []);
                        discovered.ranks = new Set(saveData.discovered.ranks || []);
                        discovered.secrets = new Set(saveData.discovered.secrets || []);
                        discovered.enchants = new Set(saveData.discovered.enchants || []);
                    }
                    
                    inventory = saveData.inventory || [];
                    inventory.forEach(item => {
                        if (!item.enchants) item.enchants = [];
                    });
                    
                    enchantOrbs = saveData.enchantOrbs || [];
                    enchantOrbs.forEach(orb => {
                        if (orb.stars === undefined) orb.stars = 0;
                        if (orb.locked === undefined) orb.locked = false;
                        if (orb.rollsWithOvertime === undefined) orb.rollsWithOvertime = 0;
                    });
                    
                    equippedOrb = saveData.equippedOrb || null;
                    if (equippedOrb) {
                        if (equippedOrb.stars === undefined) equippedOrb.stars = 0;
                        if (equippedOrb.locked === undefined) equippedOrb.locked = false;
                        if (equippedOrb.rollsWithOvertime === undefined) equippedOrb.rollsWithOvertime = 0;
                    }
                    
                    startTicketTimer();
                }
            } catch (error) {
                console.log('no save data found or error loading:', error);
                equippedOrb = null;
                startTicketTimer();
            }
            
            updateSlots();
            updateInventory();
            updateEnchantInventory();
            updateMergeSelects();
            updateIndex();
            updateBottomStats();
            updateUI();
            
            if (spinnerUnlocked) {
                document.getElementById('spinnerSection').style.display = 'block';
                createSpinnerWheel();
            }
        }

        // initialize
        updateSlots();
        updateUI();
        updateIndex();
        updateBottomStats();
        updateMergeSelects();
        initDragScrolling();
        
        document.getElementById('inventoryContent').classList.add('open');
        document.getElementById('enchantsContent').classList.add('open');
        
        document.querySelectorAll('.index-items').forEach(el => {
            el.classList.add('collapsed');
        });
        document.querySelectorAll('.index-title').forEach(el => {
            el.classList.add('collapsed');
        });
        
        // Start completionist animation
        startCompletionistAnimation();
    </script>
</body>
</html>
